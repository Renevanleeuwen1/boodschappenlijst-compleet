{"ast":null,"code":"// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { APIResource } from \"../../core/resource.mjs\";\nimport { CursorPage, Page } from \"../../core/pagination.mjs\";\nimport { buildHeaders } from \"../../internal/headers.mjs\";\nimport { sleep } from \"../../internal/utils.mjs\";\nimport { path } from \"../../internal/utils/path.mjs\";\nexport class Files extends APIResource {\n  /**\r\n   * Create a vector store file by attaching a\r\n   * [File](https://platform.openai.com/docs/api-reference/files) to a\r\n   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).\r\n   */\n  create(vectorStoreID, body, options) {\n    return this._client.post(path`/vector_stores/${vectorStoreID}/files`, {\n      body,\n      ...options,\n      headers: buildHeaders([{\n        'OpenAI-Beta': 'assistants=v2'\n      }, options?.headers])\n    });\n  }\n  /**\r\n   * Retrieves a vector store file.\r\n   */\n  retrieve(fileID, params, options) {\n    const {\n      vector_store_id\n    } = params;\n    return this._client.get(path`/vector_stores/${vector_store_id}/files/${fileID}`, {\n      ...options,\n      headers: buildHeaders([{\n        'OpenAI-Beta': 'assistants=v2'\n      }, options?.headers])\n    });\n  }\n  /**\r\n   * Update attributes on a vector store file.\r\n   */\n  update(fileID, params, options) {\n    const {\n      vector_store_id,\n      ...body\n    } = params;\n    return this._client.post(path`/vector_stores/${vector_store_id}/files/${fileID}`, {\n      body,\n      ...options,\n      headers: buildHeaders([{\n        'OpenAI-Beta': 'assistants=v2'\n      }, options?.headers])\n    });\n  }\n  /**\r\n   * Returns a list of vector store files.\r\n   */\n  list(vectorStoreID, query = {}, options) {\n    return this._client.getAPIList(path`/vector_stores/${vectorStoreID}/files`, CursorPage, {\n      query,\n      ...options,\n      headers: buildHeaders([{\n        'OpenAI-Beta': 'assistants=v2'\n      }, options?.headers])\n    });\n  }\n  /**\r\n   * Delete a vector store file. This will remove the file from the vector store but\r\n   * the file itself will not be deleted. To delete the file, use the\r\n   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)\r\n   * endpoint.\r\n   */\n  delete(fileID, params, options) {\n    const {\n      vector_store_id\n    } = params;\n    return this._client.delete(path`/vector_stores/${vector_store_id}/files/${fileID}`, {\n      ...options,\n      headers: buildHeaders([{\n        'OpenAI-Beta': 'assistants=v2'\n      }, options?.headers])\n    });\n  }\n  /**\r\n   * Attach a file to the given vector store and wait for it to be processed.\r\n   */\n  async createAndPoll(vectorStoreId, body, options) {\n    const file = await this.create(vectorStoreId, body, options);\n    return await this.poll(vectorStoreId, file.id, options);\n  }\n  /**\r\n   * Wait for the vector store file to finish processing.\r\n   *\r\n   * Note: this will return even if the file failed to process, you need to check\r\n   * file.last_error and file.status to handle these cases\r\n   */\n  async poll(vectorStoreID, fileID, options) {\n    const headers = buildHeaders([options?.headers, {\n      'X-Stainless-Poll-Helper': 'true',\n      'X-Stainless-Custom-Poll-Interval': options?.pollIntervalMs?.toString() ?? undefined\n    }]);\n    while (true) {\n      const fileResponse = await this.retrieve(fileID, {\n        vector_store_id: vectorStoreID\n      }, {\n        ...options,\n        headers\n      }).withResponse();\n      const file = fileResponse.data;\n      switch (file.status) {\n        case 'in_progress':\n          let sleepInterval = 5000;\n          if (options?.pollIntervalMs) {\n            sleepInterval = options.pollIntervalMs;\n          } else {\n            const headerInterval = fileResponse.response.headers.get('openai-poll-after-ms');\n            if (headerInterval) {\n              const headerIntervalMs = parseInt(headerInterval);\n              if (!isNaN(headerIntervalMs)) {\n                sleepInterval = headerIntervalMs;\n              }\n            }\n          }\n          await sleep(sleepInterval);\n          break;\n        case 'failed':\n        case 'completed':\n          return file;\n      }\n    }\n  }\n  /**\r\n   * Upload a file to the `files` API and then attach it to the given vector store.\r\n   *\r\n   * Note the file will be asynchronously processed (you can use the alternative\r\n   * polling helper method to wait for processing to complete).\r\n   */\n  async upload(vectorStoreId, file, options) {\n    const fileInfo = await this._client.files.create({\n      file: file,\n      purpose: 'assistants'\n    }, options);\n    return this.create(vectorStoreId, {\n      file_id: fileInfo.id\n    }, options);\n  }\n  /**\r\n   * Add a file to a vector store and poll until processing is complete.\r\n   */\n  async uploadAndPoll(vectorStoreId, file, options) {\n    const fileInfo = await this.upload(vectorStoreId, file, options);\n    return await this.poll(vectorStoreId, fileInfo.id, options);\n  }\n  /**\r\n   * Retrieve the parsed contents of a vector store file.\r\n   */\n  content(fileID, params, options) {\n    const {\n      vector_store_id\n    } = params;\n    return this._client.getAPIList(path`/vector_stores/${vector_store_id}/files/${fileID}/content`, Page, {\n      ...options,\n      headers: buildHeaders([{\n        'OpenAI-Beta': 'assistants=v2'\n      }, options?.headers])\n    });\n  }\n}","map":{"version":3,"names":["APIResource","CursorPage","Page","buildHeaders","sleep","path","Files","create","vectorStoreID","body","options","_client","post","headers","retrieve","fileID","params","vector_store_id","get","update","list","query","getAPIList","delete","createAndPoll","vectorStoreId","file","poll","id","pollIntervalMs","toString","undefined","fileResponse","withResponse","data","status","sleepInterval","headerInterval","response","headerIntervalMs","parseInt","isNaN","upload","fileInfo","files","purpose","file_id","uploadAndPoll","content"],"sources":["C:\\boodschappenlijst\\boodschappenlijst-compleet\\node_modules\\openai\\src\\resources\\vector-stores\\files.ts"],"sourcesContent":["// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from '../../core/resource';\r\nimport * as VectorStoresAPI from './vector-stores';\r\nimport { APIPromise } from '../../core/api-promise';\r\nimport { CursorPage, type CursorPageParams, PagePromise, Page } from '../../core/pagination';\r\nimport { buildHeaders } from '../../internal/headers';\r\nimport { RequestOptions } from '../../internal/request-options';\r\nimport { sleep } from '../../internal/utils';\r\nimport { Uploadable } from '../../uploads';\r\nimport { path } from '../../internal/utils/path';\r\n\r\nexport class Files extends APIResource {\r\n  /**\r\n   * Create a vector store file by attaching a\r\n   * [File](https://platform.openai.com/docs/api-reference/files) to a\r\n   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).\r\n   */\r\n  create(\r\n    vectorStoreID: string,\r\n    body: FileCreateParams,\r\n    options?: RequestOptions,\r\n  ): APIPromise<VectorStoreFile> {\r\n    return this._client.post(path`/vector_stores/${vectorStoreID}/files`, {\r\n      body,\r\n      ...options,\r\n      headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Retrieves a vector store file.\r\n   */\r\n  retrieve(\r\n    fileID: string,\r\n    params: FileRetrieveParams,\r\n    options?: RequestOptions,\r\n  ): APIPromise<VectorStoreFile> {\r\n    const { vector_store_id } = params;\r\n    return this._client.get(path`/vector_stores/${vector_store_id}/files/${fileID}`, {\r\n      ...options,\r\n      headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update attributes on a vector store file.\r\n   */\r\n  update(fileID: string, params: FileUpdateParams, options?: RequestOptions): APIPromise<VectorStoreFile> {\r\n    const { vector_store_id, ...body } = params;\r\n    return this._client.post(path`/vector_stores/${vector_store_id}/files/${fileID}`, {\r\n      body,\r\n      ...options,\r\n      headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns a list of vector store files.\r\n   */\r\n  list(\r\n    vectorStoreID: string,\r\n    query: FileListParams | null | undefined = {},\r\n    options?: RequestOptions,\r\n  ): PagePromise<VectorStoreFilesPage, VectorStoreFile> {\r\n    return this._client.getAPIList(path`/vector_stores/${vectorStoreID}/files`, CursorPage<VectorStoreFile>, {\r\n      query,\r\n      ...options,\r\n      headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Delete a vector store file. This will remove the file from the vector store but\r\n   * the file itself will not be deleted. To delete the file, use the\r\n   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)\r\n   * endpoint.\r\n   */\r\n  delete(\r\n    fileID: string,\r\n    params: FileDeleteParams,\r\n    options?: RequestOptions,\r\n  ): APIPromise<VectorStoreFileDeleted> {\r\n    const { vector_store_id } = params;\r\n    return this._client.delete(path`/vector_stores/${vector_store_id}/files/${fileID}`, {\r\n      ...options,\r\n      headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Attach a file to the given vector store and wait for it to be processed.\r\n   */\r\n  async createAndPoll(\r\n    vectorStoreId: string,\r\n    body: FileCreateParams,\r\n    options?: RequestOptions & { pollIntervalMs?: number },\r\n  ): Promise<VectorStoreFile> {\r\n    const file = await this.create(vectorStoreId, body, options);\r\n    return await this.poll(vectorStoreId, file.id, options);\r\n  }\r\n  /**\r\n   * Wait for the vector store file to finish processing.\r\n   *\r\n   * Note: this will return even if the file failed to process, you need to check\r\n   * file.last_error and file.status to handle these cases\r\n   */\r\n  async poll(\r\n    vectorStoreID: string,\r\n    fileID: string,\r\n    options?: RequestOptions & { pollIntervalMs?: number },\r\n  ): Promise<VectorStoreFile> {\r\n    const headers = buildHeaders([\r\n      options?.headers,\r\n      {\r\n        'X-Stainless-Poll-Helper': 'true',\r\n        'X-Stainless-Custom-Poll-Interval': options?.pollIntervalMs?.toString() ?? undefined,\r\n      },\r\n    ]);\r\n\r\n    while (true) {\r\n      const fileResponse = await this.retrieve(\r\n        fileID,\r\n        {\r\n          vector_store_id: vectorStoreID,\r\n        },\r\n        { ...options, headers },\r\n      ).withResponse();\r\n\r\n      const file = fileResponse.data;\r\n\r\n      switch (file.status) {\r\n        case 'in_progress':\r\n          let sleepInterval = 5000;\r\n\r\n          if (options?.pollIntervalMs) {\r\n            sleepInterval = options.pollIntervalMs;\r\n          } else {\r\n            const headerInterval = fileResponse.response.headers.get('openai-poll-after-ms');\r\n            if (headerInterval) {\r\n              const headerIntervalMs = parseInt(headerInterval);\r\n              if (!isNaN(headerIntervalMs)) {\r\n                sleepInterval = headerIntervalMs;\r\n              }\r\n            }\r\n          }\r\n          await sleep(sleepInterval);\r\n          break;\r\n        case 'failed':\r\n        case 'completed':\r\n          return file;\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Upload a file to the `files` API and then attach it to the given vector store.\r\n   *\r\n   * Note the file will be asynchronously processed (you can use the alternative\r\n   * polling helper method to wait for processing to complete).\r\n   */\r\n  async upload(vectorStoreId: string, file: Uploadable, options?: RequestOptions): Promise<VectorStoreFile> {\r\n    const fileInfo = await this._client.files.create({ file: file, purpose: 'assistants' }, options);\r\n    return this.create(vectorStoreId, { file_id: fileInfo.id }, options);\r\n  }\r\n  /**\r\n   * Add a file to a vector store and poll until processing is complete.\r\n   */\r\n  async uploadAndPoll(\r\n    vectorStoreId: string,\r\n    file: Uploadable,\r\n    options?: RequestOptions & { pollIntervalMs?: number },\r\n  ): Promise<VectorStoreFile> {\r\n    const fileInfo = await this.upload(vectorStoreId, file, options);\r\n    return await this.poll(vectorStoreId, fileInfo.id, options);\r\n  }\r\n\r\n  /**\r\n   * Retrieve the parsed contents of a vector store file.\r\n   */\r\n  content(\r\n    fileID: string,\r\n    params: FileContentParams,\r\n    options?: RequestOptions,\r\n  ): PagePromise<FileContentResponsesPage, FileContentResponse> {\r\n    const { vector_store_id } = params;\r\n    return this._client.getAPIList(\r\n      path`/vector_stores/${vector_store_id}/files/${fileID}/content`,\r\n      Page<FileContentResponse>,\r\n      { ...options, headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]) },\r\n    );\r\n  }\r\n}\r\n\r\nexport type VectorStoreFilesPage = CursorPage<VectorStoreFile>;\r\n\r\n// Note: no pagination actually occurs yet, this is for forwards-compatibility.\r\nexport type FileContentResponsesPage = Page<FileContentResponse>;\r\n\r\n/**\r\n * A list of files attached to a vector store.\r\n */\r\nexport interface VectorStoreFile {\r\n  /**\r\n   * The identifier, which can be referenced in API endpoints.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) for when the vector store file was created.\r\n   */\r\n  created_at: number;\r\n\r\n  /**\r\n   * The last error associated with this vector store file. Will be `null` if there\r\n   * are no errors.\r\n   */\r\n  last_error: VectorStoreFile.LastError | null;\r\n\r\n  /**\r\n   * The object type, which is always `vector_store.file`.\r\n   */\r\n  object: 'vector_store.file';\r\n\r\n  /**\r\n   * The status of the vector store file, which can be either `in_progress`,\r\n   * `completed`, `cancelled`, or `failed`. The status `completed` indicates that the\r\n   * vector store file is ready for use.\r\n   */\r\n  status: 'in_progress' | 'completed' | 'cancelled' | 'failed';\r\n\r\n  /**\r\n   * The total vector store usage in bytes. Note that this may be different from the\r\n   * original file size.\r\n   */\r\n  usage_bytes: number;\r\n\r\n  /**\r\n   * The ID of the\r\n   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\r\n   * that the [File](https://platform.openai.com/docs/api-reference/files) is\r\n   * attached to.\r\n   */\r\n  vector_store_id: string;\r\n\r\n  /**\r\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\r\n   * for storing additional information about the object in a structured format, and\r\n   * querying for objects via API or the dashboard. Keys are strings with a maximum\r\n   * length of 64 characters. Values are strings with a maximum length of 512\r\n   * characters, booleans, or numbers.\r\n   */\r\n  attributes?: Record<string, string | number | boolean> | null;\r\n\r\n  /**\r\n   * The strategy used to chunk the file.\r\n   */\r\n  chunking_strategy?: VectorStoresAPI.FileChunkingStrategy;\r\n}\r\n\r\nexport namespace VectorStoreFile {\r\n  /**\r\n   * The last error associated with this vector store file. Will be `null` if there\r\n   * are no errors.\r\n   */\r\n  export interface LastError {\r\n    /**\r\n     * One of `server_error` or `rate_limit_exceeded`.\r\n     */\r\n    code: 'server_error' | 'unsupported_file' | 'invalid_file';\r\n\r\n    /**\r\n     * A human-readable description of the error.\r\n     */\r\n    message: string;\r\n  }\r\n}\r\n\r\nexport interface VectorStoreFileDeleted {\r\n  id: string;\r\n\r\n  deleted: boolean;\r\n\r\n  object: 'vector_store.file.deleted';\r\n}\r\n\r\nexport interface FileContentResponse {\r\n  /**\r\n   * The text content\r\n   */\r\n  text?: string;\r\n\r\n  /**\r\n   * The content type (currently only `\"text\"`)\r\n   */\r\n  type?: string;\r\n}\r\n\r\nexport interface FileCreateParams {\r\n  /**\r\n   * A [File](https://platform.openai.com/docs/api-reference/files) ID that the\r\n   * vector store should use. Useful for tools like `file_search` that can access\r\n   * files.\r\n   */\r\n  file_id: string;\r\n\r\n  /**\r\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\r\n   * for storing additional information about the object in a structured format, and\r\n   * querying for objects via API or the dashboard. Keys are strings with a maximum\r\n   * length of 64 characters. Values are strings with a maximum length of 512\r\n   * characters, booleans, or numbers.\r\n   */\r\n  attributes?: Record<string, string | number | boolean> | null;\r\n\r\n  /**\r\n   * The chunking strategy used to chunk the file(s). If not set, will use the `auto`\r\n   * strategy. Only applicable if `file_ids` is non-empty.\r\n   */\r\n  chunking_strategy?: VectorStoresAPI.FileChunkingStrategyParam;\r\n}\r\n\r\nexport interface FileRetrieveParams {\r\n  /**\r\n   * The ID of the vector store that the file belongs to.\r\n   */\r\n  vector_store_id: string;\r\n}\r\n\r\nexport interface FileUpdateParams {\r\n  /**\r\n   * Path param: The ID of the vector store the file belongs to.\r\n   */\r\n  vector_store_id: string;\r\n\r\n  /**\r\n   * Body param: Set of 16 key-value pairs that can be attached to an object. This\r\n   * can be useful for storing additional information about the object in a\r\n   * structured format, and querying for objects via API or the dashboard. Keys are\r\n   * strings with a maximum length of 64 characters. Values are strings with a\r\n   * maximum length of 512 characters, booleans, or numbers.\r\n   */\r\n  attributes: Record<string, string | number | boolean> | null;\r\n}\r\n\r\nexport interface FileListParams extends CursorPageParams {\r\n  /**\r\n   * A cursor for use in pagination. `before` is an object ID that defines your place\r\n   * in the list. For instance, if you make a list request and receive 100 objects,\r\n   * starting with obj_foo, your subsequent call can include before=obj_foo in order\r\n   * to fetch the previous page of the list.\r\n   */\r\n  before?: string;\r\n\r\n  /**\r\n   * Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`.\r\n   */\r\n  filter?: 'in_progress' | 'completed' | 'failed' | 'cancelled';\r\n\r\n  /**\r\n   * Sort order by the `created_at` timestamp of the objects. `asc` for ascending\r\n   * order and `desc` for descending order.\r\n   */\r\n  order?: 'asc' | 'desc';\r\n}\r\n\r\nexport interface FileDeleteParams {\r\n  /**\r\n   * The ID of the vector store that the file belongs to.\r\n   */\r\n  vector_store_id: string;\r\n}\r\n\r\nexport interface FileContentParams {\r\n  /**\r\n   * The ID of the vector store.\r\n   */\r\n  vector_store_id: string;\r\n}\r\n\r\nexport declare namespace Files {\r\n  export {\r\n    type VectorStoreFile as VectorStoreFile,\r\n    type VectorStoreFileDeleted as VectorStoreFileDeleted,\r\n    type FileContentResponse as FileContentResponse,\r\n    type VectorStoreFilesPage as VectorStoreFilesPage,\r\n    type FileContentResponsesPage as FileContentResponsesPage,\r\n    type FileCreateParams as FileCreateParams,\r\n    type FileRetrieveParams as FileRetrieveParams,\r\n    type FileUpdateParams as FileUpdateParams,\r\n    type FileListParams as FileListParams,\r\n    type FileDeleteParams as FileDeleteParams,\r\n    type FileContentParams as FileContentParams,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}