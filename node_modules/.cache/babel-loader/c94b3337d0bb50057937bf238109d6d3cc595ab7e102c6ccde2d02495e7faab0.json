{"ast":null,"code":"import { OpenAIError } from \"./error.mjs\";\nimport { makeReadableStream } from \"../internal/shims.mjs\";\nimport { findDoubleNewlineIndex, LineDecoder } from \"../internal/decoders/line.mjs\";\nimport { ReadableStreamToAsyncIterable } from \"../internal/shims.mjs\";\nimport { isAbortError } from \"../internal/errors.mjs\";\nimport { encodeUTF8 } from \"../internal/utils/bytes.mjs\";\nimport { APIError } from \"./error.mjs\";\nexport class Stream {\n  constructor(iterator, controller) {\n    this.iterator = iterator;\n    this.controller = controller;\n  }\n  static fromSSEResponse(response, controller) {\n    let consumed = false;\n    async function* iterator() {\n      if (consumed) {\n        throw new OpenAIError('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const sse of _iterSSEMessages(response, controller)) {\n          if (done) continue;\n          if (sse.data.startsWith('[DONE]')) {\n            done = true;\n            continue;\n          }\n          if (sse.event === null || sse.event.startsWith('response.') || sse.event.startsWith('transcript.')) {\n            let data;\n            try {\n              data = JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n            if (data && data.error) {\n              throw new APIError(undefined, data.error, undefined, response.headers);\n            }\n            yield data;\n          } else {\n            let data;\n            try {\n              data = JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n            // TODO: Is this where the error should be thrown?\n            if (sse.event == 'error') {\n              throw new APIError(undefined, data.error, data.message, undefined);\n            }\n            yield {\n              event: sse.event,\n              data: data\n            };\n          }\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (isAbortError(e)) return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n    return new Stream(iterator, controller);\n  }\n  /**\r\n   * Generates a Stream from a newline-separated ReadableStream\r\n   * where each item is a JSON value.\r\n   */\n  static fromReadableStream(readableStream, controller) {\n    let consumed = false;\n    async function* iterLines() {\n      const lineDecoder = new LineDecoder();\n      const iter = ReadableStreamToAsyncIterable(readableStream);\n      for await (const chunk of iter) {\n        for (const line of lineDecoder.decode(chunk)) {\n          yield line;\n        }\n      }\n      for (const line of lineDecoder.flush()) {\n        yield line;\n      }\n    }\n    async function* iterator() {\n      if (consumed) {\n        throw new OpenAIError('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const line of iterLines()) {\n          if (done) continue;\n          if (line) yield JSON.parse(line);\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (isAbortError(e)) return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n    return new Stream(iterator, controller);\n  }\n  [Symbol.asyncIterator]() {\n    return this.iterator();\n  }\n  /**\r\n   * Splits the stream into two streams which can be\r\n   * independently read from at different speeds.\r\n   */\n  tee() {\n    const left = [];\n    const right = [];\n    const iterator = this.iterator();\n    const teeIterator = queue => {\n      return {\n        next: () => {\n          if (queue.length === 0) {\n            const result = iterator.next();\n            left.push(result);\n            right.push(result);\n          }\n          return queue.shift();\n        }\n      };\n    };\n    return [new Stream(() => teeIterator(left), this.controller), new Stream(() => teeIterator(right), this.controller)];\n  }\n  /**\r\n   * Converts this stream to a newline-separated ReadableStream of\r\n   * JSON stringified values in the stream\r\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\r\n   */\n  toReadableStream() {\n    const self = this;\n    let iter;\n    return makeReadableStream({\n      async start() {\n        iter = self[Symbol.asyncIterator]();\n      },\n      async pull(ctrl) {\n        try {\n          const {\n            value,\n            done\n          } = await iter.next();\n          if (done) return ctrl.close();\n          const bytes = encodeUTF8(JSON.stringify(value) + '\\n');\n          ctrl.enqueue(bytes);\n        } catch (err) {\n          ctrl.error(err);\n        }\n      },\n      async cancel() {\n        await iter.return?.();\n      }\n    });\n  }\n}\nexport async function* _iterSSEMessages(response, controller) {\n  if (!response.body) {\n    controller.abort();\n    if (typeof globalThis.navigator !== 'undefined' && globalThis.navigator.product === 'ReactNative') {\n      throw new OpenAIError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);\n    }\n    throw new OpenAIError(`Attempted to iterate over a response with no body`);\n  }\n  const sseDecoder = new SSEDecoder();\n  const lineDecoder = new LineDecoder();\n  const iter = ReadableStreamToAsyncIterable(response.body);\n  for await (const sseChunk of iterSSEChunks(iter)) {\n    for (const line of lineDecoder.decode(sseChunk)) {\n      const sse = sseDecoder.decode(line);\n      if (sse) yield sse;\n    }\n  }\n  for (const line of lineDecoder.flush()) {\n    const sse = sseDecoder.decode(line);\n    if (sse) yield sse;\n  }\n}\n/**\r\n * Given an async iterable iterator, iterates over it and yields full\r\n * SSE chunks, i.e. yields when a double new-line is encountered.\r\n */\nasync function* iterSSEChunks(iterator) {\n  let data = new Uint8Array();\n  for await (const chunk of iterator) {\n    if (chunk == null) {\n      continue;\n    }\n    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === 'string' ? encodeUTF8(chunk) : chunk;\n    let newData = new Uint8Array(data.length + binaryChunk.length);\n    newData.set(data);\n    newData.set(binaryChunk, data.length);\n    data = newData;\n    let patternIndex;\n    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\n      yield data.slice(0, patternIndex);\n      data = data.slice(patternIndex);\n    }\n  }\n  if (data.length > 0) {\n    yield data;\n  }\n}\nclass SSEDecoder {\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n  decode(line) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n      const sse = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks\n      };\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n      return sse;\n    }\n    this.chunks.push(line);\n    if (line.startsWith(':')) {\n      return null;\n    }\n    let [fieldname, _, value] = partition(line, ':');\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n    return null;\n  }\n}\nfunction partition(str, delimiter) {\n  const index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n  return [str, '', ''];\n}","map":{"version":3,"names":["OpenAIError","makeReadableStream","findDoubleNewlineIndex","LineDecoder","ReadableStreamToAsyncIterable","isAbortError","encodeUTF8","APIError","Stream","constructor","iterator","controller","fromSSEResponse","response","consumed","done","sse","_iterSSEMessages","data","startsWith","event","JSON","parse","e","console","error","raw","undefined","headers","message","abort","fromReadableStream","readableStream","iterLines","lineDecoder","iter","chunk","line","decode","flush","Symbol","asyncIterator","tee","left","right","teeIterator","queue","next","length","result","push","shift","toReadableStream","self","start","pull","ctrl","value","close","bytes","stringify","enqueue","err","cancel","return","body","globalThis","navigator","product","sseDecoder","SSEDecoder","sseChunk","iterSSEChunks","Uint8Array","binaryChunk","ArrayBuffer","newData","set","patternIndex","slice","chunks","endsWith","substring","join","fieldname","_","partition","str","delimiter","index","indexOf"],"sources":["C:\\boodschappenlijst\\boodschappenlijst-nieuw\\node_modules\\openai\\src\\core\\streaming.ts"],"sourcesContent":["import { OpenAIError } from './error';\r\nimport { type ReadableStream } from '../internal/shim-types';\r\nimport { makeReadableStream } from '../internal/shims';\r\nimport { findDoubleNewlineIndex, LineDecoder } from '../internal/decoders/line';\r\nimport { ReadableStreamToAsyncIterable } from '../internal/shims';\r\nimport { isAbortError } from '../internal/errors';\r\nimport { encodeUTF8 } from '../internal/utils/bytes';\r\n\r\nimport { APIError } from './error';\r\n\r\ntype Bytes = string | ArrayBuffer | Uint8Array | null | undefined;\r\n\r\nexport type ServerSentEvent = {\r\n  event: string | null;\r\n  data: string;\r\n  raw: string[];\r\n};\r\n\r\nexport class Stream<Item> implements AsyncIterable<Item> {\r\n  controller: AbortController;\r\n\r\n  constructor(\r\n    private iterator: () => AsyncIterator<Item>,\r\n    controller: AbortController,\r\n  ) {\r\n    this.controller = controller;\r\n  }\r\n\r\n  static fromSSEResponse<Item>(response: Response, controller: AbortController): Stream<Item> {\r\n    let consumed = false;\r\n\r\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\r\n      if (consumed) {\r\n        throw new OpenAIError('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\r\n      }\r\n      consumed = true;\r\n      let done = false;\r\n      try {\r\n        for await (const sse of _iterSSEMessages(response, controller)) {\r\n          if (done) continue;\r\n\r\n          if (sse.data.startsWith('[DONE]')) {\r\n            done = true;\r\n            continue;\r\n          }\r\n\r\n          if (\r\n            sse.event === null ||\r\n            sse.event.startsWith('response.') ||\r\n            sse.event.startsWith('transcript.')\r\n          ) {\r\n            let data;\r\n\r\n            try {\r\n              data = JSON.parse(sse.data);\r\n            } catch (e) {\r\n              console.error(`Could not parse message into JSON:`, sse.data);\r\n              console.error(`From chunk:`, sse.raw);\r\n              throw e;\r\n            }\r\n\r\n            if (data && data.error) {\r\n              throw new APIError(undefined, data.error, undefined, response.headers);\r\n            }\r\n\r\n            yield data;\r\n          } else {\r\n            let data;\r\n            try {\r\n              data = JSON.parse(sse.data);\r\n            } catch (e) {\r\n              console.error(`Could not parse message into JSON:`, sse.data);\r\n              console.error(`From chunk:`, sse.raw);\r\n              throw e;\r\n            }\r\n            // TODO: Is this where the error should be thrown?\r\n            if (sse.event == 'error') {\r\n              throw new APIError(undefined, data.error, data.message, undefined);\r\n            }\r\n            yield { event: sse.event, data: data } as any;\r\n          }\r\n        }\r\n        done = true;\r\n      } catch (e) {\r\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\r\n        if (isAbortError(e)) return;\r\n        throw e;\r\n      } finally {\r\n        // If the user `break`s, abort the ongoing request.\r\n        if (!done) controller.abort();\r\n      }\r\n    }\r\n\r\n    return new Stream(iterator, controller);\r\n  }\r\n\r\n  /**\r\n   * Generates a Stream from a newline-separated ReadableStream\r\n   * where each item is a JSON value.\r\n   */\r\n  static fromReadableStream<Item>(readableStream: ReadableStream, controller: AbortController): Stream<Item> {\r\n    let consumed = false;\r\n\r\n    async function* iterLines(): AsyncGenerator<string, void, unknown> {\r\n      const lineDecoder = new LineDecoder();\r\n\r\n      const iter = ReadableStreamToAsyncIterable<Bytes>(readableStream);\r\n      for await (const chunk of iter) {\r\n        for (const line of lineDecoder.decode(chunk)) {\r\n          yield line;\r\n        }\r\n      }\r\n\r\n      for (const line of lineDecoder.flush()) {\r\n        yield line;\r\n      }\r\n    }\r\n\r\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\r\n      if (consumed) {\r\n        throw new OpenAIError('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\r\n      }\r\n      consumed = true;\r\n      let done = false;\r\n      try {\r\n        for await (const line of iterLines()) {\r\n          if (done) continue;\r\n          if (line) yield JSON.parse(line);\r\n        }\r\n        done = true;\r\n      } catch (e) {\r\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\r\n        if (isAbortError(e)) return;\r\n        throw e;\r\n      } finally {\r\n        // If the user `break`s, abort the ongoing request.\r\n        if (!done) controller.abort();\r\n      }\r\n    }\r\n\r\n    return new Stream(iterator, controller);\r\n  }\r\n\r\n  [Symbol.asyncIterator](): AsyncIterator<Item> {\r\n    return this.iterator();\r\n  }\r\n\r\n  /**\r\n   * Splits the stream into two streams which can be\r\n   * independently read from at different speeds.\r\n   */\r\n  tee(): [Stream<Item>, Stream<Item>] {\r\n    const left: Array<Promise<IteratorResult<Item>>> = [];\r\n    const right: Array<Promise<IteratorResult<Item>>> = [];\r\n    const iterator = this.iterator();\r\n\r\n    const teeIterator = (queue: Array<Promise<IteratorResult<Item>>>): AsyncIterator<Item> => {\r\n      return {\r\n        next: () => {\r\n          if (queue.length === 0) {\r\n            const result = iterator.next();\r\n            left.push(result);\r\n            right.push(result);\r\n          }\r\n          return queue.shift()!;\r\n        },\r\n      };\r\n    };\r\n\r\n    return [\r\n      new Stream(() => teeIterator(left), this.controller),\r\n      new Stream(() => teeIterator(right), this.controller),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Converts this stream to a newline-separated ReadableStream of\r\n   * JSON stringified values in the stream\r\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\r\n   */\r\n  toReadableStream(): ReadableStream {\r\n    const self = this;\r\n    let iter: AsyncIterator<Item>;\r\n\r\n    return makeReadableStream({\r\n      async start() {\r\n        iter = self[Symbol.asyncIterator]();\r\n      },\r\n      async pull(ctrl: any) {\r\n        try {\r\n          const { value, done } = await iter.next();\r\n          if (done) return ctrl.close();\r\n\r\n          const bytes = encodeUTF8(JSON.stringify(value) + '\\n');\r\n\r\n          ctrl.enqueue(bytes);\r\n        } catch (err) {\r\n          ctrl.error(err);\r\n        }\r\n      },\r\n      async cancel() {\r\n        await iter.return?.();\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport async function* _iterSSEMessages(\r\n  response: Response,\r\n  controller: AbortController,\r\n): AsyncGenerator<ServerSentEvent, void, unknown> {\r\n  if (!response.body) {\r\n    controller.abort();\r\n    if (\r\n      typeof (globalThis as any).navigator !== 'undefined' &&\r\n      (globalThis as any).navigator.product === 'ReactNative'\r\n    ) {\r\n      throw new OpenAIError(\r\n        `The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`,\r\n      );\r\n    }\r\n    throw new OpenAIError(`Attempted to iterate over a response with no body`);\r\n  }\r\n\r\n  const sseDecoder = new SSEDecoder();\r\n  const lineDecoder = new LineDecoder();\r\n\r\n  const iter = ReadableStreamToAsyncIterable<Bytes>(response.body);\r\n  for await (const sseChunk of iterSSEChunks(iter)) {\r\n    for (const line of lineDecoder.decode(sseChunk)) {\r\n      const sse = sseDecoder.decode(line);\r\n      if (sse) yield sse;\r\n    }\r\n  }\r\n\r\n  for (const line of lineDecoder.flush()) {\r\n    const sse = sseDecoder.decode(line);\r\n    if (sse) yield sse;\r\n  }\r\n}\r\n\r\n/**\r\n * Given an async iterable iterator, iterates over it and yields full\r\n * SSE chunks, i.e. yields when a double new-line is encountered.\r\n */\r\nasync function* iterSSEChunks(iterator: AsyncIterableIterator<Bytes>): AsyncGenerator<Uint8Array> {\r\n  let data = new Uint8Array();\r\n\r\n  for await (const chunk of iterator) {\r\n    if (chunk == null) {\r\n      continue;\r\n    }\r\n\r\n    const binaryChunk =\r\n      chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\r\n      : typeof chunk === 'string' ? encodeUTF8(chunk)\r\n      : chunk;\r\n\r\n    let newData = new Uint8Array(data.length + binaryChunk.length);\r\n    newData.set(data);\r\n    newData.set(binaryChunk, data.length);\r\n    data = newData;\r\n\r\n    let patternIndex;\r\n    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\r\n      yield data.slice(0, patternIndex);\r\n      data = data.slice(patternIndex);\r\n    }\r\n  }\r\n\r\n  if (data.length > 0) {\r\n    yield data;\r\n  }\r\n}\r\n\r\nclass SSEDecoder {\r\n  private data: string[];\r\n  private event: string | null;\r\n  private chunks: string[];\r\n\r\n  constructor() {\r\n    this.event = null;\r\n    this.data = [];\r\n    this.chunks = [];\r\n  }\r\n\r\n  decode(line: string) {\r\n    if (line.endsWith('\\r')) {\r\n      line = line.substring(0, line.length - 1);\r\n    }\r\n\r\n    if (!line) {\r\n      // empty line and we didn't previously encounter any messages\r\n      if (!this.event && !this.data.length) return null;\r\n\r\n      const sse: ServerSentEvent = {\r\n        event: this.event,\r\n        data: this.data.join('\\n'),\r\n        raw: this.chunks,\r\n      };\r\n\r\n      this.event = null;\r\n      this.data = [];\r\n      this.chunks = [];\r\n\r\n      return sse;\r\n    }\r\n\r\n    this.chunks.push(line);\r\n\r\n    if (line.startsWith(':')) {\r\n      return null;\r\n    }\r\n\r\n    let [fieldname, _, value] = partition(line, ':');\r\n\r\n    if (value.startsWith(' ')) {\r\n      value = value.substring(1);\r\n    }\r\n\r\n    if (fieldname === 'event') {\r\n      this.event = value;\r\n    } else if (fieldname === 'data') {\r\n      this.data.push(value);\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nfunction partition(str: string, delimiter: string): [string, string, string] {\r\n  const index = str.indexOf(delimiter);\r\n  if (index !== -1) {\r\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\r\n  }\r\n\r\n  return [str, '', ''];\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}