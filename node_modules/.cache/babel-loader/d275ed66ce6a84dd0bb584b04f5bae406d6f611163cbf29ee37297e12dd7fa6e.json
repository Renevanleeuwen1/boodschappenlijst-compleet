{"ast":null,"code":"// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { Stream } from \"../core/streaming.mjs\";\nimport { formatRequestDetails, loggerFor } from \"./utils/log.mjs\";\nexport async function defaultParseResponse(client, props) {\n  const {\n    response,\n    requestLogID,\n    retryOfRequestLogID,\n    startTime\n  } = props;\n  const body = await (async () => {\n    if (props.options.stream) {\n      loggerFor(client).debug('response', response.status, response.url, response.headers, response.body);\n      // Note: there is an invariant here that isn't represented in the type system\n      // that if you set `stream: true` the response type must also be `Stream<T>`\n      if (props.options.__streamClass) {\n        return props.options.__streamClass.fromSSEResponse(response, props.controller);\n      }\n      return Stream.fromSSEResponse(response, props.controller);\n    }\n    // fetch refuses to read the body when the status code is 204.\n    if (response.status === 204) {\n      return null;\n    }\n    if (props.options.__binaryResponse) {\n      return response;\n    }\n    const contentType = response.headers.get('content-type');\n    const mediaType = contentType?.split(';')[0]?.trim();\n    const isJSON = mediaType?.includes('application/json') || mediaType?.endsWith('+json');\n    if (isJSON) {\n      const json = await response.json();\n      return addRequestID(json, response);\n    }\n    const text = await response.text();\n    return text;\n  })();\n  loggerFor(client).debug(`[${requestLogID}] response parsed`, formatRequestDetails({\n    retryOfRequestLogID,\n    url: response.url,\n    status: response.status,\n    body,\n    durationMs: Date.now() - startTime\n  }));\n  return body;\n}\nexport function addRequestID(value, response) {\n  if (!value || typeof value !== 'object' || Array.isArray(value)) {\n    return value;\n  }\n  return Object.defineProperty(value, '_request_id', {\n    value: response.headers.get('x-request-id'),\n    enumerable: false\n  });\n}","map":{"version":3,"names":["Stream","formatRequestDetails","loggerFor","defaultParseResponse","client","props","response","requestLogID","retryOfRequestLogID","startTime","body","options","stream","debug","status","url","headers","__streamClass","fromSSEResponse","controller","__binaryResponse","contentType","get","mediaType","split","trim","isJSON","includes","endsWith","json","addRequestID","text","durationMs","Date","now","value","Array","isArray","Object","defineProperty","enumerable"],"sources":["C:\\boodschappenlijst\\boodschappenlijst-compleet\\node_modules\\openai\\src\\internal\\parse.ts"],"sourcesContent":["// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport type { FinalRequestOptions } from './request-options';\r\nimport { Stream } from '../core/streaming';\r\nimport { type OpenAI } from '../client';\r\nimport { formatRequestDetails, loggerFor } from './utils/log';\r\nimport type { AbstractPage } from '../pagination';\r\n\r\nexport type APIResponseProps = {\r\n  response: Response;\r\n  options: FinalRequestOptions;\r\n  controller: AbortController;\r\n  requestLogID: string;\r\n  retryOfRequestLogID: string | undefined;\r\n  startTime: number;\r\n};\r\n\r\nexport async function defaultParseResponse<T>(\r\n  client: OpenAI,\r\n  props: APIResponseProps,\r\n): Promise<WithRequestID<T>> {\r\n  const { response, requestLogID, retryOfRequestLogID, startTime } = props;\r\n  const body = await (async () => {\r\n    if (props.options.stream) {\r\n      loggerFor(client).debug('response', response.status, response.url, response.headers, response.body);\r\n\r\n      // Note: there is an invariant here that isn't represented in the type system\r\n      // that if you set `stream: true` the response type must also be `Stream<T>`\r\n\r\n      if (props.options.__streamClass) {\r\n        return props.options.__streamClass.fromSSEResponse(response, props.controller) as any;\r\n      }\r\n\r\n      return Stream.fromSSEResponse(response, props.controller) as any;\r\n    }\r\n\r\n    // fetch refuses to read the body when the status code is 204.\r\n    if (response.status === 204) {\r\n      return null as T;\r\n    }\r\n\r\n    if (props.options.__binaryResponse) {\r\n      return response as unknown as T;\r\n    }\r\n\r\n    const contentType = response.headers.get('content-type');\r\n    const mediaType = contentType?.split(';')[0]?.trim();\r\n    const isJSON = mediaType?.includes('application/json') || mediaType?.endsWith('+json');\r\n    if (isJSON) {\r\n      const json = await response.json();\r\n      return addRequestID(json as T, response);\r\n    }\r\n\r\n    const text = await response.text();\r\n    return text as unknown as T;\r\n  })();\r\n  loggerFor(client).debug(\r\n    `[${requestLogID}] response parsed`,\r\n    formatRequestDetails({\r\n      retryOfRequestLogID,\r\n      url: response.url,\r\n      status: response.status,\r\n      body,\r\n      durationMs: Date.now() - startTime,\r\n    }),\r\n  );\r\n  return body;\r\n}\r\n\r\nexport type WithRequestID<T> =\r\n  T extends Array<any> | Response | AbstractPage<any> ? T\r\n  : T extends Record<string, any> ? T & { _request_id?: string | null }\r\n  : T;\r\n\r\nexport function addRequestID<T>(value: T, response: Response): WithRequestID<T> {\r\n  if (!value || typeof value !== 'object' || Array.isArray(value)) {\r\n    return value as WithRequestID<T>;\r\n  }\r\n\r\n  return Object.defineProperty(value, '_request_id', {\r\n    value: response.headers.get('x-request-id'),\r\n    enumerable: false,\r\n  }) as WithRequestID<T>;\r\n}\r\n"],"mappings":"AAAA;SAGSA,MAAM,QAAE;SAERC,oBAAoB,EAAEC,SAAS,QAAE;AAY1C,OAAO,eAAeC,oBAAoBA,CACxCC,MAAc,EACdC,KAAuB;EAEvB,MAAM;IAAEC,QAAQ;IAAEC,YAAY;IAAEC,mBAAmB;IAAEC;EAAS,CAAE,GAAGJ,KAAK;EACxE,MAAMK,IAAI,GAAG,MAAM,CAAC,YAAW;IAC7B,IAAIL,KAAK,CAACM,OAAO,CAACC,MAAM,EAAE;MACxBV,SAAS,CAACE,MAAM,CAAC,CAACS,KAAK,CAAC,UAAU,EAAEP,QAAQ,CAACQ,MAAM,EAAER,QAAQ,CAACS,GAAG,EAAET,QAAQ,CAACU,OAAO,EAAEV,QAAQ,CAACI,IAAI,CAAC;MAEnG;MACA;MAEA,IAAIL,KAAK,CAACM,OAAO,CAACM,aAAa,EAAE;QAC/B,OAAOZ,KAAK,CAACM,OAAO,CAACM,aAAa,CAACC,eAAe,CAACZ,QAAQ,EAAED,KAAK,CAACc,UAAU,CAAQ;MACvF;MAEA,OAAOnB,MAAM,CAACkB,eAAe,CAACZ,QAAQ,EAAED,KAAK,CAACc,UAAU,CAAQ;IAClE;IAEA;IACA,IAAIb,QAAQ,CAACQ,MAAM,KAAK,GAAG,EAAE;MAC3B,OAAO,IAAS;IAClB;IAEA,IAAIT,KAAK,CAACM,OAAO,CAACS,gBAAgB,EAAE;MAClC,OAAOd,QAAwB;IACjC;IAEA,MAAMe,WAAW,GAAGf,QAAQ,CAACU,OAAO,CAACM,GAAG,CAAC,cAAc,CAAC;IACxD,MAAMC,SAAS,GAAGF,WAAW,EAAEG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAEC,IAAI,EAAE;IACpD,MAAMC,MAAM,GAAGH,SAAS,EAAEI,QAAQ,CAAC,kBAAkB,CAAC,IAAIJ,SAAS,EAAEK,QAAQ,CAAC,OAAO,CAAC;IACtF,IAAIF,MAAM,EAAE;MACV,MAAMG,IAAI,GAAG,MAAMvB,QAAQ,CAACuB,IAAI,EAAE;MAClC,OAAOC,YAAY,CAACD,IAAS,EAAEvB,QAAQ,CAAC;IAC1C;IAEA,MAAMyB,IAAI,GAAG,MAAMzB,QAAQ,CAACyB,IAAI,EAAE;IAClC,OAAOA,IAAoB;EAC7B,CAAC,EAAC,CAAE;EACJ7B,SAAS,CAACE,MAAM,CAAC,CAACS,KAAK,CACrB,IAAIN,YAAY,mBAAmB,EACnCN,oBAAoB,CAAC;IACnBO,mBAAmB;IACnBO,GAAG,EAAET,QAAQ,CAACS,GAAG;IACjBD,MAAM,EAAER,QAAQ,CAACQ,MAAM;IACvBJ,IAAI;IACJsB,UAAU,EAAEC,IAAI,CAACC,GAAG,EAAE,GAAGzB;GAC1B,CAAC,CACH;EACD,OAAOC,IAAI;AACb;AAOA,OAAM,SAAUoB,YAAYA,CAAIK,KAAQ,EAAE7B,QAAkB;EAC1D,IAAI,CAAC6B,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;IAC/D,OAAOA,KAAyB;EAClC;EAEA,OAAOG,MAAM,CAACC,cAAc,CAACJ,KAAK,EAAE,aAAa,EAAE;IACjDA,KAAK,EAAE7B,QAAQ,CAACU,OAAO,CAACM,GAAG,CAAC,cAAc,CAAC;IAC3CkB,UAAU,EAAE;GACb,CAAqB;AACxB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}