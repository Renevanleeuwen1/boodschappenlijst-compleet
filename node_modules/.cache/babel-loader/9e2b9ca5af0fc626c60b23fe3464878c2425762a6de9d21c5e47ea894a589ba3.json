{"ast":null,"code":"var _ChatCompletionStream_instances, _ChatCompletionStream_params, _ChatCompletionStream_choiceEventStates, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_getChoiceEventState, _ChatCompletionStream_addChunk, _ChatCompletionStream_emitToolCallDoneEvent, _ChatCompletionStream_emitContentDoneEvents, _ChatCompletionStream_endRequest, _ChatCompletionStream_getAutoParseableResponseFormat, _ChatCompletionStream_accumulateChatCompletion;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"../internal/tslib.mjs\";\nimport { OpenAIError, APIUserAbortError, LengthFinishReasonError, ContentFilterFinishReasonError } from \"../error.mjs\";\nimport { AbstractChatCompletionRunner } from \"./AbstractChatCompletionRunner.mjs\";\nimport { Stream } from \"../streaming.mjs\";\nimport { hasAutoParseableInput, isAutoParsableResponseFormat, isAutoParsableTool, maybeParseChatCompletion, shouldParseToolCall } from \"../lib/parser.mjs\";\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.mjs\";\nexport class ChatCompletionStream extends AbstractChatCompletionRunner {\n  constructor(params) {\n    super();\n    _ChatCompletionStream_instances.add(this);\n    _ChatCompletionStream_params.set(this, void 0);\n    _ChatCompletionStream_choiceEventStates.set(this, void 0);\n    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);\n    __classPrivateFieldSet(this, _ChatCompletionStream_params, params, \"f\");\n    __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], \"f\");\n  }\n  get currentChatCompletionSnapshot() {\n    return __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n  }\n  /**\r\n   * Intended for use on the frontend, consuming a stream produced with\r\n   * `.toReadableStream()` on the backend.\r\n   *\r\n   * Note that messages sent to the model do not appear in `.on('message')`\r\n   * in this context.\r\n   */\n  static fromReadableStream(stream) {\n    const runner = new ChatCompletionStream(null);\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n  static createChatCompletion(client, params, options) {\n    const runner = new ChatCompletionStream(params);\n    runner._run(() => runner._runChatCompletion(client, {\n      ...params,\n      stream: true\n    }, {\n      ...options,\n      headers: {\n        ...options?.headers,\n        'X-Stainless-Helper-Method': 'stream'\n      }\n    }));\n    return runner;\n  }\n  async _createChatCompletion(client, params, options) {\n    super._createChatCompletion;\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n    const stream = await client.chat.completions.create({\n      ...params,\n      stream: true\n    }, {\n      ...options,\n      signal: this.controller.signal\n    });\n    this._connected();\n    for await (const chunk of stream) {\n      __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n  }\n  async _fromReadableStream(readableStream, options) {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n    this._connected();\n    const stream = Stream.fromReadableStream(readableStream, this.controller);\n    let chatId;\n    for await (const chunk of stream) {\n      if (chatId && chatId !== chunk.id) {\n        // A new request has been made.\n        this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n      }\n      __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n      chatId = chunk.id;\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n  }\n  [(_ChatCompletionStream_params = new WeakMap(), _ChatCompletionStream_choiceEventStates = new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = new WeakMap(), _ChatCompletionStream_instances = new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest() {\n    if (this.ended) return;\n    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n  }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState(choice) {\n    let state = __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, \"f\")[choice.index];\n    if (state) {\n      return state;\n    }\n    state = {\n      content_done: false,\n      refusal_done: false,\n      logprobs_content_done: false,\n      logprobs_refusal_done: false,\n      done_tool_calls: new Set(),\n      current_tool_call_index: null\n    };\n    __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, \"f\")[choice.index] = state;\n    return state;\n  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk(chunk) {\n    if (this.ended) return;\n    const completion = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);\n    this._emit('chunk', chunk, completion);\n    for (const choice of chunk.choices) {\n      const choiceSnapshot = completion.choices[choice.index];\n      if (choice.delta.content != null && choiceSnapshot.message?.role === 'assistant' && choiceSnapshot.message?.content) {\n        this._emit('content', choice.delta.content, choiceSnapshot.message.content);\n        this._emit('content.delta', {\n          delta: choice.delta.content,\n          snapshot: choiceSnapshot.message.content,\n          parsed: choiceSnapshot.message.parsed\n        });\n      }\n      if (choice.delta.refusal != null && choiceSnapshot.message?.role === 'assistant' && choiceSnapshot.message?.refusal) {\n        this._emit('refusal.delta', {\n          delta: choice.delta.refusal,\n          snapshot: choiceSnapshot.message.refusal\n        });\n      }\n      if (choice.logprobs?.content != null && choiceSnapshot.message?.role === 'assistant') {\n        this._emit('logprobs.content.delta', {\n          content: choice.logprobs?.content,\n          snapshot: choiceSnapshot.logprobs?.content ?? []\n        });\n      }\n      if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === 'assistant') {\n        this._emit('logprobs.refusal.delta', {\n          refusal: choice.logprobs?.refusal,\n          snapshot: choiceSnapshot.logprobs?.refusal ?? []\n        });\n      }\n      const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n      if (choiceSnapshot.finish_reason) {\n        __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);\n        if (state.current_tool_call_index != null) {\n          __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);\n        }\n      }\n      for (const toolCall of choice.delta.tool_calls ?? []) {\n        if (state.current_tool_call_index !== toolCall.index) {\n          __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);\n          // new tool call started, the previous one is done\n          if (state.current_tool_call_index != null) {\n            __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);\n          }\n        }\n        state.current_tool_call_index = toolCall.index;\n      }\n      for (const toolCallDelta of choice.delta.tool_calls ?? []) {\n        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];\n        if (!toolCallSnapshot?.type) {\n          continue;\n        }\n        if (toolCallSnapshot?.type === 'function') {\n          this._emit('tool_calls.function.arguments.delta', {\n            name: toolCallSnapshot.function?.name,\n            index: toolCallDelta.index,\n            arguments: toolCallSnapshot.function.arguments,\n            parsed_arguments: toolCallSnapshot.function.parsed_arguments,\n            arguments_delta: toolCallDelta.function?.arguments ?? ''\n          });\n        } else {\n          assertNever(toolCallSnapshot?.type);\n        }\n      }\n    }\n  }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent(choiceSnapshot, toolCallIndex) {\n    const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n    if (state.done_tool_calls.has(toolCallIndex)) {\n      // we've already fired the done event\n      return;\n    }\n    const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];\n    if (!toolCallSnapshot) {\n      throw new Error('no tool call snapshot');\n    }\n    if (!toolCallSnapshot.type) {\n      throw new Error('tool call snapshot missing `type`');\n    }\n    if (toolCallSnapshot.type === 'function') {\n      const inputTool = __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\")?.tools?.find(tool => tool.type === 'function' && tool.function.name === toolCallSnapshot.function.name);\n      this._emit('tool_calls.function.arguments.done', {\n        name: toolCallSnapshot.function.name,\n        index: toolCallIndex,\n        arguments: toolCallSnapshot.function.arguments,\n        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments) : null\n      });\n    } else {\n      assertNever(toolCallSnapshot.type);\n    }\n  }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents(choiceSnapshot) {\n    const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n    if (choiceSnapshot.message.content && !state.content_done) {\n      state.content_done = true;\n      const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);\n      this._emit('content.done', {\n        content: choiceSnapshot.message.content,\n        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null\n      });\n    }\n    if (choiceSnapshot.message.refusal && !state.refusal_done) {\n      state.refusal_done = true;\n      this._emit('refusal.done', {\n        refusal: choiceSnapshot.message.refusal\n      });\n    }\n    if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {\n      state.logprobs_content_done = true;\n      this._emit('logprobs.content.done', {\n        content: choiceSnapshot.logprobs.content\n      });\n    }\n    if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {\n      state.logprobs_refusal_done = true;\n      this._emit('logprobs.refusal.done', {\n        refusal: choiceSnapshot.logprobs.refusal\n      });\n    }\n  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest() {\n    if (this.ended) {\n      throw new OpenAIError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n    if (!snapshot) {\n      throw new OpenAIError(`request ended without sending any chunks`);\n    }\n    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n    __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], \"f\");\n    return finalizeChatCompletion(snapshot, __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"));\n  }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat() {\n    const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\")?.response_format;\n    if (isAutoParsableResponseFormat(responseFormat)) {\n      return responseFormat;\n    }\n    return null;\n  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion(chunk) {\n    var _a, _b, _c, _d;\n    let snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n    const {\n      choices,\n      ...rest\n    } = chunk;\n    if (!snapshot) {\n      snapshot = __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, {\n        ...rest,\n        choices: []\n      }, \"f\");\n    } else {\n      Object.assign(snapshot, rest);\n    }\n    for (const {\n      delta,\n      finish_reason,\n      index,\n      logprobs = null,\n      ...other\n    } of chunk.choices) {\n      let choice = snapshot.choices[index];\n      if (!choice) {\n        choice = snapshot.choices[index] = {\n          finish_reason,\n          index,\n          message: {},\n          logprobs,\n          ...other\n        };\n      }\n      if (logprobs) {\n        if (!choice.logprobs) {\n          choice.logprobs = Object.assign({}, logprobs);\n        } else {\n          const {\n            content,\n            refusal,\n            ...rest\n          } = logprobs;\n          assertIsEmpty(rest);\n          Object.assign(choice.logprobs, rest);\n          if (content) {\n            (_a = choice.logprobs).content ?? (_a.content = []);\n            choice.logprobs.content.push(...content);\n          }\n          if (refusal) {\n            (_b = choice.logprobs).refusal ?? (_b.refusal = []);\n            choice.logprobs.refusal.push(...refusal);\n          }\n        }\n      }\n      if (finish_reason) {\n        choice.finish_reason = finish_reason;\n        if (__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\") && hasAutoParseableInput(__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"))) {\n          if (finish_reason === 'length') {\n            throw new LengthFinishReasonError();\n          }\n          if (finish_reason === 'content_filter') {\n            throw new ContentFilterFinishReasonError();\n          }\n        }\n      }\n      Object.assign(choice, other);\n      if (!delta) continue; // Shouldn't happen; just in case.\n      const {\n        content,\n        refusal,\n        function_call,\n        role,\n        tool_calls,\n        ...rest\n      } = delta;\n      assertIsEmpty(rest);\n      Object.assign(choice.message, rest);\n      if (refusal) {\n        choice.message.refusal = (choice.message.refusal || '') + refusal;\n      }\n      if (role) choice.message.role = role;\n      if (function_call) {\n        if (!choice.message.function_call) {\n          choice.message.function_call = function_call;\n        } else {\n          if (function_call.name) choice.message.function_call.name = function_call.name;\n          if (function_call.arguments) {\n            (_c = choice.message.function_call).arguments ?? (_c.arguments = '');\n            choice.message.function_call.arguments += function_call.arguments;\n          }\n        }\n      }\n      if (content) {\n        choice.message.content = (choice.message.content || '') + content;\n        if (!choice.message.refusal && __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {\n          choice.message.parsed = partialParse(choice.message.content);\n        }\n      }\n      if (tool_calls) {\n        if (!choice.message.tool_calls) choice.message.tool_calls = [];\n        for (const {\n          index,\n          id,\n          type,\n          function: fn,\n          ...rest\n        } of tool_calls) {\n          const tool_call = (_d = choice.message.tool_calls)[index] ?? (_d[index] = {});\n          Object.assign(tool_call, rest);\n          if (id) tool_call.id = id;\n          if (type) tool_call.type = type;\n          if (fn) tool_call.function ?? (tool_call.function = {\n            name: fn.name ?? '',\n            arguments: ''\n          });\n          if (fn?.name) tool_call.function.name = fn.name;\n          if (fn?.arguments) {\n            tool_call.function.arguments += fn.arguments;\n            if (shouldParseToolCall(__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"), tool_call)) {\n              tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);\n            }\n          }\n        }\n      }\n    }\n    return snapshot;\n  }, Symbol.asyncIterator)]() {\n    const pushQueue = [];\n    const readQueue = [];\n    let done = false;\n    this.on('chunk', chunk => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(chunk);\n      } else {\n        pushQueue.push(chunk);\n      }\n    });\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n    this.on('abort', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    this.on('error', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    return {\n      next: async () => {\n        if (!pushQueue.length) {\n          if (done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          return new Promise((resolve, reject) => readQueue.push({\n            resolve,\n            reject\n          })).then(chunk => chunk ? {\n            value: chunk,\n            done: false\n          } : {\n            value: undefined,\n            done: true\n          });\n        }\n        const chunk = pushQueue.shift();\n        return {\n          value: chunk,\n          done: false\n        };\n      },\n      return: async () => {\n        this.abort();\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  toReadableStream() {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}\nfunction finalizeChatCompletion(snapshot, params) {\n  const {\n    id,\n    choices,\n    created,\n    model,\n    system_fingerprint,\n    ...rest\n  } = snapshot;\n  const completion = {\n    ...rest,\n    id,\n    choices: choices.map(({\n      message,\n      finish_reason,\n      index,\n      logprobs,\n      ...choiceRest\n    }) => {\n      if (!finish_reason) {\n        throw new OpenAIError(`missing finish_reason for choice ${index}`);\n      }\n      const {\n        content = null,\n        function_call,\n        tool_calls,\n        ...messageRest\n      } = message;\n      const role = message.role; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.\n      if (!role) {\n        throw new OpenAIError(`missing role for choice ${index}`);\n      }\n      if (function_call) {\n        const {\n          arguments: args,\n          name\n        } = function_call;\n        if (args == null) {\n          throw new OpenAIError(`missing function_call.arguments for choice ${index}`);\n        }\n        if (!name) {\n          throw new OpenAIError(`missing function_call.name for choice ${index}`);\n        }\n        return {\n          ...choiceRest,\n          message: {\n            content,\n            function_call: {\n              arguments: args,\n              name\n            },\n            role,\n            refusal: message.refusal ?? null\n          },\n          finish_reason,\n          index,\n          logprobs\n        };\n      }\n      if (tool_calls) {\n        return {\n          ...choiceRest,\n          index,\n          finish_reason,\n          logprobs,\n          message: {\n            ...messageRest,\n            role,\n            content,\n            refusal: message.refusal ?? null,\n            tool_calls: tool_calls.map((tool_call, i) => {\n              const {\n                function: fn,\n                type,\n                id,\n                ...toolRest\n              } = tool_call;\n              const {\n                arguments: args,\n                name,\n                ...fnRest\n              } = fn || {};\n              if (id == null) {\n                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id\\n${str(snapshot)}`);\n              }\n              if (type == null) {\n                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type\\n${str(snapshot)}`);\n              }\n              if (name == null) {\n                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name\\n${str(snapshot)}`);\n              }\n              if (args == null) {\n                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments\\n${str(snapshot)}`);\n              }\n              return {\n                ...toolRest,\n                id,\n                type,\n                function: {\n                  ...fnRest,\n                  name,\n                  arguments: args\n                }\n              };\n            })\n          }\n        };\n      }\n      return {\n        ...choiceRest,\n        message: {\n          ...messageRest,\n          content,\n          role,\n          refusal: message.refusal ?? null\n        },\n        finish_reason,\n        index,\n        logprobs\n      };\n    }),\n    created,\n    model,\n    object: 'chat.completion',\n    ...(system_fingerprint ? {\n      system_fingerprint\n    } : {})\n  };\n  return maybeParseChatCompletion(completion, params);\n}\nfunction str(x) {\n  return JSON.stringify(x);\n}\n/**\r\n * Ensures the given argument is an empty object, useful for\r\n * asserting that all known properties on an object have been\r\n * destructured.\r\n */\nfunction assertIsEmpty(obj) {\n  return;\n}\nfunction assertNever(_x) {}","map":{"version":3,"names":["OpenAIError","APIUserAbortError","LengthFinishReasonError","ContentFilterFinishReasonError","AbstractChatCompletionRunner","Stream","hasAutoParseableInput","isAutoParsableResponseFormat","isAutoParsableTool","maybeParseChatCompletion","shouldParseToolCall","partialParse","ChatCompletionStream","constructor","params","_ChatCompletionStream_params","set","_ChatCompletionStream_choiceEventStates","_ChatCompletionStream_currentChatCompletionSnapshot","__classPrivateFieldSet","currentChatCompletionSnapshot","__classPrivateFieldGet","fromReadableStream","stream","runner","_run","_fromReadableStream","createChatCompletion","client","options","_runChatCompletion","headers","_createChatCompletion","signal","aborted","controller","abort","addEventListener","_ChatCompletionStream_instances","_ChatCompletionStream_beginRequest","call","chat","completions","create","_connected","chunk","_ChatCompletionStream_addChunk","_addChatCompletion","_ChatCompletionStream_endRequest","readableStream","chatId","id","WeakMap","WeakSet","ended","undefined","_ChatCompletionStream_getChoiceEventState","choice","state","index","content_done","refusal_done","logprobs_content_done","logprobs_refusal_done","done_tool_calls","Set","current_tool_call_index","completion","_ChatCompletionStream_accumulateChatCompletion","_emit","choices","choiceSnapshot","delta","content","message","role","snapshot","parsed","refusal","logprobs","finish_reason","_ChatCompletionStream_emitContentDoneEvents","_ChatCompletionStream_emitToolCallDoneEvent","toolCall","tool_calls","toolCallDelta","toolCallSnapshot","type","name","function","arguments","parsed_arguments","arguments_delta","assertNever","toolCallIndex","has","Error","inputTool","tools","find","tool","$parseRaw","strict","JSON","parse","responseFormat","_ChatCompletionStream_getAutoParseableResponseFormat","finalizeChatCompletion","response_format","rest","Object","assign","other","assertIsEmpty","_a","push","_b","function_call","_c","fn","tool_call","_d","Symbol","asyncIterator","pushQueue","readQueue","done","on","reader","shift","resolve","length","err","reject","next","value","Promise","then","return","toReadableStream","bind","created","model","system_fingerprint","map","choiceRest","messageRest","args","i","toolRest","fnRest","str","object","x","stringify","obj","_x"],"sources":["C:\\boodschappenlijst\\boodschappenlijst-nieuw\\node_modules\\openai\\src\\lib\\ChatCompletionStream.ts"],"sourcesContent":["import {\r\n  OpenAIError,\r\n  APIUserAbortError,\r\n  LengthFinishReasonError,\r\n  ContentFilterFinishReasonError,\r\n} from '../error';\r\nimport {\r\n  ChatCompletionTokenLogprob,\r\n  type ChatCompletion,\r\n  type ChatCompletionChunk,\r\n  type ChatCompletionCreateParams,\r\n  type ChatCompletionCreateParamsStreaming,\r\n  type ChatCompletionCreateParamsBase,\r\n  type ChatCompletionRole,\r\n} from '../resources/chat/completions/completions';\r\nimport {\r\n  AbstractChatCompletionRunner,\r\n  type AbstractChatCompletionRunnerEvents,\r\n} from './AbstractChatCompletionRunner';\r\nimport { type ReadableStream } from '../internal/shim-types';\r\nimport { Stream } from '../streaming';\r\nimport OpenAI from '../index';\r\nimport { ParsedChatCompletion } from '../resources/chat/completions';\r\nimport {\r\n  AutoParseableResponseFormat,\r\n  hasAutoParseableInput,\r\n  isAutoParsableResponseFormat,\r\n  isAutoParsableTool,\r\n  maybeParseChatCompletion,\r\n  shouldParseToolCall,\r\n} from '../lib/parser';\r\nimport { partialParse } from '../_vendor/partial-json-parser/parser';\r\nimport { RequestOptions } from '../internal/request-options';\r\n\r\nexport interface ContentDeltaEvent {\r\n  delta: string;\r\n  snapshot: string;\r\n  parsed: unknown | null;\r\n}\r\n\r\nexport interface ContentDoneEvent<ParsedT = null> {\r\n  content: string;\r\n  parsed: ParsedT | null;\r\n}\r\n\r\nexport interface RefusalDeltaEvent {\r\n  delta: string;\r\n  snapshot: string;\r\n}\r\n\r\nexport interface RefusalDoneEvent {\r\n  refusal: string;\r\n}\r\n\r\nexport interface FunctionToolCallArgumentsDeltaEvent {\r\n  name: string;\r\n\r\n  index: number;\r\n\r\n  arguments: string;\r\n\r\n  parsed_arguments: unknown;\r\n\r\n  arguments_delta: string;\r\n}\r\n\r\nexport interface FunctionToolCallArgumentsDoneEvent {\r\n  name: string;\r\n\r\n  index: number;\r\n\r\n  arguments: string;\r\n\r\n  parsed_arguments: unknown;\r\n}\r\n\r\nexport interface LogProbsContentDeltaEvent {\r\n  content: Array<ChatCompletionTokenLogprob>;\r\n  snapshot: Array<ChatCompletionTokenLogprob>;\r\n}\r\n\r\nexport interface LogProbsContentDoneEvent {\r\n  content: Array<ChatCompletionTokenLogprob>;\r\n}\r\n\r\nexport interface LogProbsRefusalDeltaEvent {\r\n  refusal: Array<ChatCompletionTokenLogprob>;\r\n  snapshot: Array<ChatCompletionTokenLogprob>;\r\n}\r\n\r\nexport interface LogProbsRefusalDoneEvent {\r\n  refusal: Array<ChatCompletionTokenLogprob>;\r\n}\r\n\r\nexport interface ChatCompletionStreamEvents<ParsedT = null> extends AbstractChatCompletionRunnerEvents {\r\n  content: (contentDelta: string, contentSnapshot: string) => void;\r\n  chunk: (chunk: ChatCompletionChunk, snapshot: ChatCompletionSnapshot) => void;\r\n\r\n  'content.delta': (props: ContentDeltaEvent) => void;\r\n  'content.done': (props: ContentDoneEvent<ParsedT>) => void;\r\n\r\n  'refusal.delta': (props: RefusalDeltaEvent) => void;\r\n  'refusal.done': (props: RefusalDoneEvent) => void;\r\n\r\n  'tool_calls.function.arguments.delta': (props: FunctionToolCallArgumentsDeltaEvent) => void;\r\n  'tool_calls.function.arguments.done': (props: FunctionToolCallArgumentsDoneEvent) => void;\r\n\r\n  'logprobs.content.delta': (props: LogProbsContentDeltaEvent) => void;\r\n  'logprobs.content.done': (props: LogProbsContentDoneEvent) => void;\r\n\r\n  'logprobs.refusal.delta': (props: LogProbsRefusalDeltaEvent) => void;\r\n  'logprobs.refusal.done': (props: LogProbsRefusalDoneEvent) => void;\r\n}\r\n\r\nexport type ChatCompletionStreamParams = Omit<ChatCompletionCreateParamsBase, 'stream'> & {\r\n  stream?: true;\r\n};\r\n\r\ninterface ChoiceEventState {\r\n  content_done: boolean;\r\n  refusal_done: boolean;\r\n  logprobs_content_done: boolean;\r\n  logprobs_refusal_done: boolean;\r\n  current_tool_call_index: number | null;\r\n  done_tool_calls: Set<number>;\r\n}\r\n\r\nexport class ChatCompletionStream<ParsedT = null>\r\n  extends AbstractChatCompletionRunner<ChatCompletionStreamEvents<ParsedT>, ParsedT>\r\n  implements AsyncIterable<ChatCompletionChunk>\r\n{\r\n  #params: ChatCompletionCreateParams | null;\r\n  #choiceEventStates: ChoiceEventState[];\r\n  #currentChatCompletionSnapshot: ChatCompletionSnapshot | undefined;\r\n\r\n  constructor(params: ChatCompletionCreateParams | null) {\r\n    super();\r\n    this.#params = params;\r\n    this.#choiceEventStates = [];\r\n  }\r\n\r\n  get currentChatCompletionSnapshot(): ChatCompletionSnapshot | undefined {\r\n    return this.#currentChatCompletionSnapshot;\r\n  }\r\n\r\n  /**\r\n   * Intended for use on the frontend, consuming a stream produced with\r\n   * `.toReadableStream()` on the backend.\r\n   *\r\n   * Note that messages sent to the model do not appear in `.on('message')`\r\n   * in this context.\r\n   */\r\n  static fromReadableStream(stream: ReadableStream): ChatCompletionStream<null> {\r\n    const runner = new ChatCompletionStream(null);\r\n    runner._run(() => runner._fromReadableStream(stream));\r\n    return runner;\r\n  }\r\n\r\n  static createChatCompletion<ParsedT>(\r\n    client: OpenAI,\r\n    params: ChatCompletionStreamParams,\r\n    options?: RequestOptions,\r\n  ): ChatCompletionStream<ParsedT> {\r\n    const runner = new ChatCompletionStream<ParsedT>(params as ChatCompletionCreateParamsStreaming);\r\n    runner._run(() =>\r\n      runner._runChatCompletion(\r\n        client,\r\n        { ...params, stream: true },\r\n        { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } },\r\n      ),\r\n    );\r\n    return runner;\r\n  }\r\n\r\n  #beginRequest() {\r\n    if (this.ended) return;\r\n    this.#currentChatCompletionSnapshot = undefined;\r\n  }\r\n\r\n  #getChoiceEventState(choice: ChatCompletionSnapshot.Choice): ChoiceEventState {\r\n    let state = this.#choiceEventStates[choice.index];\r\n    if (state) {\r\n      return state;\r\n    }\r\n\r\n    state = {\r\n      content_done: false,\r\n      refusal_done: false,\r\n      logprobs_content_done: false,\r\n      logprobs_refusal_done: false,\r\n      done_tool_calls: new Set(),\r\n      current_tool_call_index: null,\r\n    };\r\n    this.#choiceEventStates[choice.index] = state;\r\n    return state;\r\n  }\r\n\r\n  #addChunk(this: ChatCompletionStream<ParsedT>, chunk: ChatCompletionChunk) {\r\n    if (this.ended) return;\r\n\r\n    const completion = this.#accumulateChatCompletion(chunk);\r\n    this._emit('chunk', chunk, completion);\r\n\r\n    for (const choice of chunk.choices) {\r\n      const choiceSnapshot = completion.choices[choice.index]!;\r\n\r\n      if (\r\n        choice.delta.content != null &&\r\n        choiceSnapshot.message?.role === 'assistant' &&\r\n        choiceSnapshot.message?.content\r\n      ) {\r\n        this._emit('content', choice.delta.content, choiceSnapshot.message.content);\r\n        this._emit('content.delta', {\r\n          delta: choice.delta.content,\r\n          snapshot: choiceSnapshot.message.content,\r\n          parsed: choiceSnapshot.message.parsed,\r\n        });\r\n      }\r\n\r\n      if (\r\n        choice.delta.refusal != null &&\r\n        choiceSnapshot.message?.role === 'assistant' &&\r\n        choiceSnapshot.message?.refusal\r\n      ) {\r\n        this._emit('refusal.delta', {\r\n          delta: choice.delta.refusal,\r\n          snapshot: choiceSnapshot.message.refusal,\r\n        });\r\n      }\r\n\r\n      if (choice.logprobs?.content != null && choiceSnapshot.message?.role === 'assistant') {\r\n        this._emit('logprobs.content.delta', {\r\n          content: choice.logprobs?.content,\r\n          snapshot: choiceSnapshot.logprobs?.content ?? [],\r\n        });\r\n      }\r\n\r\n      if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === 'assistant') {\r\n        this._emit('logprobs.refusal.delta', {\r\n          refusal: choice.logprobs?.refusal,\r\n          snapshot: choiceSnapshot.logprobs?.refusal ?? [],\r\n        });\r\n      }\r\n\r\n      const state = this.#getChoiceEventState(choiceSnapshot);\r\n\r\n      if (choiceSnapshot.finish_reason) {\r\n        this.#emitContentDoneEvents(choiceSnapshot);\r\n\r\n        if (state.current_tool_call_index != null) {\r\n          this.#emitToolCallDoneEvent(choiceSnapshot, state.current_tool_call_index);\r\n        }\r\n      }\r\n\r\n      for (const toolCall of choice.delta.tool_calls ?? []) {\r\n        if (state.current_tool_call_index !== toolCall.index) {\r\n          this.#emitContentDoneEvents(choiceSnapshot);\r\n\r\n          // new tool call started, the previous one is done\r\n          if (state.current_tool_call_index != null) {\r\n            this.#emitToolCallDoneEvent(choiceSnapshot, state.current_tool_call_index);\r\n          }\r\n        }\r\n\r\n        state.current_tool_call_index = toolCall.index;\r\n      }\r\n\r\n      for (const toolCallDelta of choice.delta.tool_calls ?? []) {\r\n        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];\r\n        if (!toolCallSnapshot?.type) {\r\n          continue;\r\n        }\r\n\r\n        if (toolCallSnapshot?.type === 'function') {\r\n          this._emit('tool_calls.function.arguments.delta', {\r\n            name: toolCallSnapshot.function?.name,\r\n            index: toolCallDelta.index,\r\n            arguments: toolCallSnapshot.function.arguments,\r\n            parsed_arguments: toolCallSnapshot.function.parsed_arguments,\r\n            arguments_delta: toolCallDelta.function?.arguments ?? '',\r\n          });\r\n        } else {\r\n          assertNever(toolCallSnapshot?.type);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  #emitToolCallDoneEvent(choiceSnapshot: ChatCompletionSnapshot.Choice, toolCallIndex: number) {\r\n    const state = this.#getChoiceEventState(choiceSnapshot);\r\n    if (state.done_tool_calls.has(toolCallIndex)) {\r\n      // we've already fired the done event\r\n      return;\r\n    }\r\n\r\n    const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];\r\n    if (!toolCallSnapshot) {\r\n      throw new Error('no tool call snapshot');\r\n    }\r\n    if (!toolCallSnapshot.type) {\r\n      throw new Error('tool call snapshot missing `type`');\r\n    }\r\n\r\n    if (toolCallSnapshot.type === 'function') {\r\n      const inputTool = this.#params?.tools?.find(\r\n        (tool) => tool.type === 'function' && tool.function.name === toolCallSnapshot.function.name,\r\n      );\r\n\r\n      this._emit('tool_calls.function.arguments.done', {\r\n        name: toolCallSnapshot.function.name,\r\n        index: toolCallIndex,\r\n        arguments: toolCallSnapshot.function.arguments,\r\n        parsed_arguments:\r\n          isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments)\r\n          : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments)\r\n          : null,\r\n      });\r\n    } else {\r\n      assertNever(toolCallSnapshot.type);\r\n    }\r\n  }\r\n\r\n  #emitContentDoneEvents(choiceSnapshot: ChatCompletionSnapshot.Choice) {\r\n    const state = this.#getChoiceEventState(choiceSnapshot);\r\n\r\n    if (choiceSnapshot.message.content && !state.content_done) {\r\n      state.content_done = true;\r\n\r\n      const responseFormat = this.#getAutoParseableResponseFormat();\r\n\r\n      this._emit('content.done', {\r\n        content: choiceSnapshot.message.content,\r\n        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : (null as any),\r\n      });\r\n    }\r\n\r\n    if (choiceSnapshot.message.refusal && !state.refusal_done) {\r\n      state.refusal_done = true;\r\n\r\n      this._emit('refusal.done', { refusal: choiceSnapshot.message.refusal });\r\n    }\r\n\r\n    if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {\r\n      state.logprobs_content_done = true;\r\n\r\n      this._emit('logprobs.content.done', { content: choiceSnapshot.logprobs.content });\r\n    }\r\n\r\n    if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {\r\n      state.logprobs_refusal_done = true;\r\n\r\n      this._emit('logprobs.refusal.done', { refusal: choiceSnapshot.logprobs.refusal });\r\n    }\r\n  }\r\n\r\n  #endRequest(): ParsedChatCompletion<ParsedT> {\r\n    if (this.ended) {\r\n      throw new OpenAIError(`stream has ended, this shouldn't happen`);\r\n    }\r\n    const snapshot = this.#currentChatCompletionSnapshot;\r\n    if (!snapshot) {\r\n      throw new OpenAIError(`request ended without sending any chunks`);\r\n    }\r\n    this.#currentChatCompletionSnapshot = undefined;\r\n    this.#choiceEventStates = [];\r\n    return finalizeChatCompletion(snapshot, this.#params);\r\n  }\r\n\r\n  protected override async _createChatCompletion(\r\n    client: OpenAI,\r\n    params: ChatCompletionCreateParams,\r\n    options?: RequestOptions,\r\n  ): Promise<ParsedChatCompletion<ParsedT>> {\r\n    super._createChatCompletion;\r\n    const signal = options?.signal;\r\n    if (signal) {\r\n      if (signal.aborted) this.controller.abort();\r\n      signal.addEventListener('abort', () => this.controller.abort());\r\n    }\r\n    this.#beginRequest();\r\n\r\n    const stream = await client.chat.completions.create(\r\n      { ...params, stream: true },\r\n      { ...options, signal: this.controller.signal },\r\n    );\r\n    this._connected();\r\n    for await (const chunk of stream) {\r\n      this.#addChunk(chunk);\r\n    }\r\n    if (stream.controller.signal?.aborted) {\r\n      throw new APIUserAbortError();\r\n    }\r\n    return this._addChatCompletion(this.#endRequest());\r\n  }\r\n\r\n  protected async _fromReadableStream(\r\n    readableStream: ReadableStream,\r\n    options?: RequestOptions,\r\n  ): Promise<ChatCompletion> {\r\n    const signal = options?.signal;\r\n    if (signal) {\r\n      if (signal.aborted) this.controller.abort();\r\n      signal.addEventListener('abort', () => this.controller.abort());\r\n    }\r\n    this.#beginRequest();\r\n    this._connected();\r\n    const stream = Stream.fromReadableStream<ChatCompletionChunk>(readableStream, this.controller);\r\n    let chatId;\r\n    for await (const chunk of stream) {\r\n      if (chatId && chatId !== chunk.id) {\r\n        // A new request has been made.\r\n        this._addChatCompletion(this.#endRequest());\r\n      }\r\n\r\n      this.#addChunk(chunk);\r\n      chatId = chunk.id;\r\n    }\r\n    if (stream.controller.signal?.aborted) {\r\n      throw new APIUserAbortError();\r\n    }\r\n    return this._addChatCompletion(this.#endRequest());\r\n  }\r\n\r\n  #getAutoParseableResponseFormat(): AutoParseableResponseFormat<ParsedT> | null {\r\n    const responseFormat = this.#params?.response_format;\r\n    if (isAutoParsableResponseFormat<ParsedT>(responseFormat)) {\r\n      return responseFormat;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  #accumulateChatCompletion(chunk: ChatCompletionChunk): ChatCompletionSnapshot {\r\n    let snapshot = this.#currentChatCompletionSnapshot;\r\n    const { choices, ...rest } = chunk;\r\n    if (!snapshot) {\r\n      snapshot = this.#currentChatCompletionSnapshot = {\r\n        ...rest,\r\n        choices: [],\r\n      };\r\n    } else {\r\n      Object.assign(snapshot, rest);\r\n    }\r\n\r\n    for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {\r\n      let choice = snapshot.choices[index];\r\n      if (!choice) {\r\n        choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };\r\n      }\r\n\r\n      if (logprobs) {\r\n        if (!choice.logprobs) {\r\n          choice.logprobs = Object.assign({}, logprobs);\r\n        } else {\r\n          const { content, refusal, ...rest } = logprobs;\r\n          assertIsEmpty(rest);\r\n          Object.assign(choice.logprobs, rest);\r\n\r\n          if (content) {\r\n            choice.logprobs.content ??= [];\r\n            choice.logprobs.content.push(...content);\r\n          }\r\n\r\n          if (refusal) {\r\n            choice.logprobs.refusal ??= [];\r\n            choice.logprobs.refusal.push(...refusal);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (finish_reason) {\r\n        choice.finish_reason = finish_reason;\r\n\r\n        if (this.#params && hasAutoParseableInput(this.#params)) {\r\n          if (finish_reason === 'length') {\r\n            throw new LengthFinishReasonError();\r\n          }\r\n\r\n          if (finish_reason === 'content_filter') {\r\n            throw new ContentFilterFinishReasonError();\r\n          }\r\n        }\r\n      }\r\n\r\n      Object.assign(choice, other);\r\n\r\n      if (!delta) continue; // Shouldn't happen; just in case.\r\n\r\n      const { content, refusal, function_call, role, tool_calls, ...rest } = delta;\r\n      assertIsEmpty(rest);\r\n      Object.assign(choice.message, rest);\r\n\r\n      if (refusal) {\r\n        choice.message.refusal = (choice.message.refusal || '') + refusal;\r\n      }\r\n\r\n      if (role) choice.message.role = role;\r\n      if (function_call) {\r\n        if (!choice.message.function_call) {\r\n          choice.message.function_call = function_call;\r\n        } else {\r\n          if (function_call.name) choice.message.function_call.name = function_call.name;\r\n          if (function_call.arguments) {\r\n            choice.message.function_call.arguments ??= '';\r\n            choice.message.function_call.arguments += function_call.arguments;\r\n          }\r\n        }\r\n      }\r\n      if (content) {\r\n        choice.message.content = (choice.message.content || '') + content;\r\n\r\n        if (!choice.message.refusal && this.#getAutoParseableResponseFormat()) {\r\n          choice.message.parsed = partialParse(choice.message.content);\r\n        }\r\n      }\r\n\r\n      if (tool_calls) {\r\n        if (!choice.message.tool_calls) choice.message.tool_calls = [];\r\n\r\n        for (const { index, id, type, function: fn, ...rest } of tool_calls) {\r\n          const tool_call = (choice.message.tool_calls[index] ??=\r\n            {} as ChatCompletionSnapshot.Choice.Message.ToolCall);\r\n          Object.assign(tool_call, rest);\r\n          if (id) tool_call.id = id;\r\n          if (type) tool_call.type = type;\r\n          if (fn) tool_call.function ??= { name: fn.name ?? '', arguments: '' };\r\n          if (fn?.name) tool_call.function!.name = fn.name;\r\n          if (fn?.arguments) {\r\n            tool_call.function!.arguments += fn.arguments;\r\n\r\n            if (shouldParseToolCall(this.#params, tool_call)) {\r\n              tool_call.function!.parsed_arguments = partialParse(tool_call.function!.arguments);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return snapshot;\r\n  }\r\n\r\n  [Symbol.asyncIterator](this: ChatCompletionStream<ParsedT>): AsyncIterator<ChatCompletionChunk> {\r\n    const pushQueue: ChatCompletionChunk[] = [];\r\n    const readQueue: {\r\n      resolve: (chunk: ChatCompletionChunk | undefined) => void;\r\n      reject: (err: unknown) => void;\r\n    }[] = [];\r\n    let done = false;\r\n\r\n    this.on('chunk', (chunk) => {\r\n      const reader = readQueue.shift();\r\n      if (reader) {\r\n        reader.resolve(chunk);\r\n      } else {\r\n        pushQueue.push(chunk);\r\n      }\r\n    });\r\n\r\n    this.on('end', () => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.resolve(undefined);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    this.on('abort', (err) => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.reject(err);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    this.on('error', (err) => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.reject(err);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    return {\r\n      next: async (): Promise<IteratorResult<ChatCompletionChunk>> => {\r\n        if (!pushQueue.length) {\r\n          if (done) {\r\n            return { value: undefined, done: true };\r\n          }\r\n          return new Promise<ChatCompletionChunk | undefined>((resolve, reject) =>\r\n            readQueue.push({ resolve, reject }),\r\n          ).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\r\n        }\r\n        const chunk = pushQueue.shift()!;\r\n        return { value: chunk, done: false };\r\n      },\r\n      return: async () => {\r\n        this.abort();\r\n        return { value: undefined, done: true };\r\n      },\r\n    };\r\n  }\r\n\r\n  toReadableStream(): ReadableStream {\r\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\r\n    return stream.toReadableStream();\r\n  }\r\n}\r\n\r\nfunction finalizeChatCompletion<ParsedT>(\r\n  snapshot: ChatCompletionSnapshot,\r\n  params: ChatCompletionCreateParams | null,\r\n): ParsedChatCompletion<ParsedT> {\r\n  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;\r\n  const completion: ChatCompletion = {\r\n    ...rest,\r\n    id,\r\n    choices: choices.map(\r\n      ({ message, finish_reason, index, logprobs, ...choiceRest }): ChatCompletion.Choice => {\r\n        if (!finish_reason) {\r\n          throw new OpenAIError(`missing finish_reason for choice ${index}`);\r\n        }\r\n\r\n        const { content = null, function_call, tool_calls, ...messageRest } = message;\r\n        const role = message.role as 'assistant'; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.\r\n        if (!role) {\r\n          throw new OpenAIError(`missing role for choice ${index}`);\r\n        }\r\n\r\n        if (function_call) {\r\n          const { arguments: args, name } = function_call;\r\n          if (args == null) {\r\n            throw new OpenAIError(`missing function_call.arguments for choice ${index}`);\r\n          }\r\n\r\n          if (!name) {\r\n            throw new OpenAIError(`missing function_call.name for choice ${index}`);\r\n          }\r\n\r\n          return {\r\n            ...choiceRest,\r\n            message: {\r\n              content,\r\n              function_call: { arguments: args, name },\r\n              role,\r\n              refusal: message.refusal ?? null,\r\n            },\r\n            finish_reason,\r\n            index,\r\n            logprobs,\r\n          };\r\n        }\r\n\r\n        if (tool_calls) {\r\n          return {\r\n            ...choiceRest,\r\n            index,\r\n            finish_reason,\r\n            logprobs,\r\n            message: {\r\n              ...messageRest,\r\n              role,\r\n              content,\r\n              refusal: message.refusal ?? null,\r\n              tool_calls: tool_calls.map((tool_call, i) => {\r\n                const { function: fn, type, id, ...toolRest } = tool_call;\r\n                const { arguments: args, name, ...fnRest } = fn || {};\r\n                if (id == null) {\r\n                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id\\n${str(snapshot)}`);\r\n                }\r\n                if (type == null) {\r\n                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type\\n${str(snapshot)}`);\r\n                }\r\n                if (name == null) {\r\n                  throw new OpenAIError(\r\n                    `missing choices[${index}].tool_calls[${i}].function.name\\n${str(snapshot)}`,\r\n                  );\r\n                }\r\n                if (args == null) {\r\n                  throw new OpenAIError(\r\n                    `missing choices[${index}].tool_calls[${i}].function.arguments\\n${str(snapshot)}`,\r\n                  );\r\n                }\r\n\r\n                return { ...toolRest, id, type, function: { ...fnRest, name, arguments: args } };\r\n              }),\r\n            },\r\n          };\r\n        }\r\n        return {\r\n          ...choiceRest,\r\n          message: { ...messageRest, content, role, refusal: message.refusal ?? null },\r\n          finish_reason,\r\n          index,\r\n          logprobs,\r\n        };\r\n      },\r\n    ),\r\n    created,\r\n    model,\r\n    object: 'chat.completion',\r\n    ...(system_fingerprint ? { system_fingerprint } : {}),\r\n  };\r\n\r\n  return maybeParseChatCompletion(completion, params);\r\n}\r\n\r\nfunction str(x: unknown) {\r\n  return JSON.stringify(x);\r\n}\r\n\r\n/**\r\n * Represents a streamed chunk of a chat completion response returned by model,\r\n * based on the provided input.\r\n */\r\nexport interface ChatCompletionSnapshot {\r\n  /**\r\n   * A unique identifier for the chat completion.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * A list of chat completion choices. Can be more than one if `n` is greater\r\n   * than 1.\r\n   */\r\n  choices: Array<ChatCompletionSnapshot.Choice>;\r\n\r\n  /**\r\n   * The Unix timestamp (in seconds) of when the chat completion was created.\r\n   */\r\n  created: number;\r\n\r\n  /**\r\n   * The model to generate the completion.\r\n   */\r\n  model: string;\r\n\r\n  // Note we do not include an \"object\" type on the snapshot,\r\n  // because the object is not a valid \"chat.completion\" until finalized.\r\n  // object: 'chat.completion';\r\n\r\n  /**\r\n   * This fingerprint represents the backend configuration that the model runs with.\r\n   *\r\n   * Can be used in conjunction with the `seed` request parameter to understand when\r\n   * backend changes have been made that might impact determinism.\r\n   */\r\n  system_fingerprint?: string;\r\n}\r\n\r\nexport namespace ChatCompletionSnapshot {\r\n  export interface Choice {\r\n    /**\r\n     * A chat completion delta generated by streamed model responses.\r\n     */\r\n    message: Choice.Message;\r\n\r\n    /**\r\n     * The reason the model stopped generating tokens. This will be `stop` if the model\r\n     * hit a natural stop point or a provided stop sequence, `length` if the maximum\r\n     * number of tokens specified in the request was reached, `content_filter` if\r\n     * content was omitted due to a flag from our content filters, or `function_call`\r\n     * if the model called a function.\r\n     */\r\n    finish_reason: ChatCompletion.Choice['finish_reason'] | null;\r\n\r\n    /**\r\n     * Log probability information for the choice.\r\n     */\r\n    logprobs: ChatCompletion.Choice.Logprobs | null;\r\n\r\n    /**\r\n     * The index of the choice in the list of choices.\r\n     */\r\n    index: number;\r\n  }\r\n\r\n  export namespace Choice {\r\n    /**\r\n     * A chat completion delta generated by streamed model responses.\r\n     */\r\n    export interface Message {\r\n      /**\r\n       * The contents of the chunk message.\r\n       */\r\n      content?: string | null;\r\n\r\n      refusal?: string | null;\r\n\r\n      parsed?: unknown | null;\r\n\r\n      /**\r\n       * The name and arguments of a function that should be called, as generated by the\r\n       * model.\r\n       */\r\n      function_call?: Message.FunctionCall;\r\n\r\n      tool_calls?: Array<Message.ToolCall>;\r\n\r\n      /**\r\n       * The role of the author of this message.\r\n       */\r\n      role?: ChatCompletionRole;\r\n    }\r\n\r\n    export namespace Message {\r\n      export interface ToolCall {\r\n        /**\r\n         * The ID of the tool call.\r\n         */\r\n        id: string;\r\n\r\n        function: ToolCall.Function;\r\n\r\n        /**\r\n         * The type of the tool.\r\n         */\r\n        type: 'function';\r\n      }\r\n\r\n      export namespace ToolCall {\r\n        export interface Function {\r\n          /**\r\n           * The arguments to call the function with, as generated by the model in JSON\r\n           * format. Note that the model does not always generate valid JSON, and may\r\n           * hallucinate parameters not defined by your function schema. Validate the\r\n           * arguments in your code before calling your function.\r\n           */\r\n          arguments: string;\r\n\r\n          parsed_arguments?: unknown;\r\n\r\n          /**\r\n           * The name of the function to call.\r\n           */\r\n          name: string;\r\n        }\r\n      }\r\n\r\n      /**\r\n       * The name and arguments of a function that should be called, as generated by the\r\n       * model.\r\n       */\r\n      export interface FunctionCall {\r\n        /**\r\n         * The arguments to call the function with, as generated by the model in JSON\r\n         * format. Note that the model does not always generate valid JSON, and may\r\n         * hallucinate parameters not defined by your function schema. Validate the\r\n         * arguments in your code before calling your function.\r\n         */\r\n        arguments?: string;\r\n\r\n        /**\r\n         * The name of the function to call.\r\n         */\r\n        name?: string;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ntype AssertIsEmpty<T extends {}> = keyof T extends never ? T : never;\r\n\r\n/**\r\n * Ensures the given argument is an empty object, useful for\r\n * asserting that all known properties on an object have been\r\n * destructured.\r\n */\r\nfunction assertIsEmpty<T extends {}>(obj: AssertIsEmpty<T>): asserts obj is AssertIsEmpty<T> {\r\n  return;\r\n}\r\n\r\nfunction assertNever(_x: never) {}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}