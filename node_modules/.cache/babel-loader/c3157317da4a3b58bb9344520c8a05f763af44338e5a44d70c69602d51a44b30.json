{"ast":null,"code":"import { OpenAIError } from \"../error.mjs\";\nimport { isAutoParsableResponseFormat } from \"../lib/parser.mjs\";\nexport function maybeParseResponse(response, params) {\n  if (!params || !hasAutoParseableInput(params)) {\n    return {\n      ...response,\n      output_parsed: null,\n      output: response.output.map(item => {\n        if (item.type === 'function_call') {\n          return {\n            ...item,\n            parsed_arguments: null\n          };\n        }\n        if (item.type === 'message') {\n          return {\n            ...item,\n            content: item.content.map(content => ({\n              ...content,\n              parsed: null\n            }))\n          };\n        } else {\n          return item;\n        }\n      })\n    };\n  }\n  return parseResponse(response, params);\n}\nexport function parseResponse(response, params) {\n  const output = response.output.map(item => {\n    if (item.type === 'function_call') {\n      return {\n        ...item,\n        parsed_arguments: parseToolCall(params, item)\n      };\n    }\n    if (item.type === 'message') {\n      const content = item.content.map(content => {\n        if (content.type === 'output_text') {\n          return {\n            ...content,\n            parsed: parseTextFormat(params, content.text)\n          };\n        }\n        return content;\n      });\n      return {\n        ...item,\n        content\n      };\n    }\n    return item;\n  });\n  const parsed = Object.assign({}, response, {\n    output\n  });\n  if (!Object.getOwnPropertyDescriptor(response, 'output_text')) {\n    addOutputText(parsed);\n  }\n  Object.defineProperty(parsed, 'output_parsed', {\n    enumerable: true,\n    get() {\n      for (const output of parsed.output) {\n        if (output.type !== 'message') {\n          continue;\n        }\n        for (const content of output.content) {\n          if (content.type === 'output_text' && content.parsed !== null) {\n            return content.parsed;\n          }\n        }\n      }\n      return null;\n    }\n  });\n  return parsed;\n}\nfunction parseTextFormat(params, content) {\n  if (params.text?.format?.type !== 'json_schema') {\n    return null;\n  }\n  if ('$parseRaw' in params.text?.format) {\n    const text_format = params.text?.format;\n    return text_format.$parseRaw(content);\n  }\n  return JSON.parse(content);\n}\nexport function hasAutoParseableInput(params) {\n  if (isAutoParsableResponseFormat(params.text?.format)) {\n    return true;\n  }\n  return false;\n}\nexport function makeParseableResponseTool(tool, {\n  parser,\n  callback\n}) {\n  const obj = {\n    ...tool\n  };\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-tool',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    },\n    $callback: {\n      value: callback,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nexport function isAutoParsableTool(tool) {\n  return tool?.['$brand'] === 'auto-parseable-tool';\n}\nfunction getInputToolByName(input_tools, name) {\n  return input_tools.find(tool => tool.type === 'function' && tool.name === name);\n}\nfunction parseToolCall(params, toolCall) {\n  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n  return {\n    ...toolCall,\n    ...toolCall,\n    parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : inputTool?.strict ? JSON.parse(toolCall.arguments) : null\n  };\n}\nexport function shouldParseToolCall(params, toolCall) {\n  if (!params) {\n    return false;\n  }\n  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n  return isAutoParsableTool(inputTool) || inputTool?.strict || false;\n}\nexport function validateInputTools(tools) {\n  for (const tool of tools ?? []) {\n    if (tool.type !== 'function') {\n      throw new OpenAIError(`Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``);\n    }\n    if (tool.function.strict !== true) {\n      throw new OpenAIError(`The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`);\n    }\n  }\n}\nexport function addOutputText(rsp) {\n  const texts = [];\n  for (const output of rsp.output) {\n    if (output.type !== 'message') {\n      continue;\n    }\n    for (const content of output.content) {\n      if (content.type === 'output_text') {\n        texts.push(content.text);\n      }\n    }\n  }\n  rsp.output_text = texts.join('');\n}","map":{"version":3,"names":["OpenAIError","isAutoParsableResponseFormat","maybeParseResponse","response","params","hasAutoParseableInput","output_parsed","output","map","item","type","parsed_arguments","content","parsed","parseResponse","parseToolCall","parseTextFormat","text","Object","assign","getOwnPropertyDescriptor","addOutputText","defineProperty","enumerable","get","format","text_format","$parseRaw","JSON","parse","makeParseableResponseTool","tool","parser","callback","obj","defineProperties","$brand","value","$callback","isAutoParsableTool","getInputToolByName","input_tools","name","find","toolCall","inputTool","tools","arguments","strict","shouldParseToolCall","validateInputTools","function","rsp","texts","push","output_text","join"],"sources":["C:\\boodschappenlijst\\boodschappenlijst-nieuw\\node_modules\\openai\\src\\lib\\ResponsesParser.ts"],"sourcesContent":["import { OpenAIError } from '../error';\r\nimport type { ChatCompletionTool } from '../resources/chat/completions';\r\nimport {\r\n  ResponseTextConfig,\r\n  type FunctionTool,\r\n  type ParsedContent,\r\n  type ParsedResponse,\r\n  type ParsedResponseFunctionToolCall,\r\n  type ParsedResponseOutputItem,\r\n  type Response,\r\n  type ResponseCreateParamsBase,\r\n  type ResponseCreateParamsNonStreaming,\r\n  type ResponseFunctionToolCall,\r\n  type Tool,\r\n} from '../resources/responses/responses';\r\nimport { type AutoParseableTextFormat, isAutoParsableResponseFormat } from '../lib/parser';\r\n\r\nexport type ParseableToolsParams = Array<Tool> | ChatCompletionTool | null;\r\n\r\nexport type ResponseCreateParamsWithTools = ResponseCreateParamsBase & {\r\n  tools?: ParseableToolsParams;\r\n};\r\n\r\ntype TextConfigParams = { text?: ResponseTextConfig };\r\n\r\nexport type ExtractParsedContentFromParams<Params extends TextConfigParams> =\r\n  NonNullable<Params['text']>['format'] extends AutoParseableTextFormat<infer P> ? P : null;\r\n\r\nexport function maybeParseResponse<\r\n  Params extends ResponseCreateParamsBase | null,\r\n  ParsedT = Params extends null ? null : ExtractParsedContentFromParams<NonNullable<Params>>,\r\n>(response: Response, params: Params): ParsedResponse<ParsedT> {\r\n  if (!params || !hasAutoParseableInput(params)) {\r\n    return {\r\n      ...response,\r\n      output_parsed: null,\r\n      output: response.output.map((item) => {\r\n        if (item.type === 'function_call') {\r\n          return {\r\n            ...item,\r\n            parsed_arguments: null,\r\n          };\r\n        }\r\n\r\n        if (item.type === 'message') {\r\n          return {\r\n            ...item,\r\n            content: item.content.map((content) => ({\r\n              ...content,\r\n              parsed: null,\r\n            })),\r\n          };\r\n        } else {\r\n          return item;\r\n        }\r\n      }),\r\n    };\r\n  }\r\n\r\n  return parseResponse(response, params);\r\n}\r\n\r\nexport function parseResponse<\r\n  Params extends ResponseCreateParamsBase,\r\n  ParsedT = ExtractParsedContentFromParams<Params>,\r\n>(response: Response, params: Params): ParsedResponse<ParsedT> {\r\n  const output: Array<ParsedResponseOutputItem<ParsedT>> = response.output.map(\r\n    (item): ParsedResponseOutputItem<ParsedT> => {\r\n      if (item.type === 'function_call') {\r\n        return {\r\n          ...item,\r\n          parsed_arguments: parseToolCall(params, item),\r\n        };\r\n      }\r\n      if (item.type === 'message') {\r\n        const content: Array<ParsedContent<ParsedT>> = item.content.map((content) => {\r\n          if (content.type === 'output_text') {\r\n            return {\r\n              ...content,\r\n              parsed: parseTextFormat(params, content.text),\r\n            };\r\n          }\r\n\r\n          return content;\r\n        });\r\n\r\n        return {\r\n          ...item,\r\n          content,\r\n        };\r\n      }\r\n\r\n      return item;\r\n    },\r\n  );\r\n\r\n  const parsed: Omit<ParsedResponse<ParsedT>, 'output_parsed'> = Object.assign({}, response, { output });\r\n  if (!Object.getOwnPropertyDescriptor(response, 'output_text')) {\r\n    addOutputText(parsed);\r\n  }\r\n\r\n  Object.defineProperty(parsed, 'output_parsed', {\r\n    enumerable: true,\r\n    get() {\r\n      for (const output of parsed.output) {\r\n        if (output.type !== 'message') {\r\n          continue;\r\n        }\r\n\r\n        for (const content of output.content) {\r\n          if (content.type === 'output_text' && content.parsed !== null) {\r\n            return content.parsed;\r\n          }\r\n        }\r\n      }\r\n\r\n      return null;\r\n    },\r\n  });\r\n\r\n  return parsed as ParsedResponse<ParsedT>;\r\n}\r\n\r\nfunction parseTextFormat<\r\n  Params extends ResponseCreateParamsBase,\r\n  ParsedT = ExtractParsedContentFromParams<Params>,\r\n>(params: Params, content: string): ParsedT | null {\r\n  if (params.text?.format?.type !== 'json_schema') {\r\n    return null;\r\n  }\r\n\r\n  if ('$parseRaw' in params.text?.format) {\r\n    const text_format = params.text?.format as unknown as AutoParseableTextFormat<ParsedT>;\r\n    return text_format.$parseRaw(content);\r\n  }\r\n\r\n  return JSON.parse(content);\r\n}\r\n\r\nexport function hasAutoParseableInput(params: ResponseCreateParamsWithTools): boolean {\r\n  if (isAutoParsableResponseFormat(params.text?.format)) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\ntype ToolOptions = {\r\n  name: string;\r\n  arguments: any;\r\n  function?: ((args: any) => any) | undefined;\r\n};\r\n\r\nexport type AutoParseableResponseTool<\r\n  OptionsT extends ToolOptions,\r\n  HasFunction = OptionsT['function'] extends Function ? true : false,\r\n> = FunctionTool & {\r\n  __arguments: OptionsT['arguments']; // type-level only\r\n  __name: OptionsT['name']; // type-level only\r\n\r\n  $brand: 'auto-parseable-tool';\r\n  $callback: ((args: OptionsT['arguments']) => any) | undefined;\r\n  $parseRaw(args: string): OptionsT['arguments'];\r\n};\r\n\r\nexport function makeParseableResponseTool<OptionsT extends ToolOptions>(\r\n  tool: FunctionTool,\r\n  {\r\n    parser,\r\n    callback,\r\n  }: {\r\n    parser: (content: string) => OptionsT['arguments'];\r\n    callback: ((args: any) => any) | undefined;\r\n  },\r\n): AutoParseableResponseTool<OptionsT['arguments']> {\r\n  const obj = { ...tool };\r\n\r\n  Object.defineProperties(obj, {\r\n    $brand: {\r\n      value: 'auto-parseable-tool',\r\n      enumerable: false,\r\n    },\r\n    $parseRaw: {\r\n      value: parser,\r\n      enumerable: false,\r\n    },\r\n    $callback: {\r\n      value: callback,\r\n      enumerable: false,\r\n    },\r\n  });\r\n\r\n  return obj as AutoParseableResponseTool<OptionsT['arguments']>;\r\n}\r\n\r\nexport function isAutoParsableTool(tool: any): tool is AutoParseableResponseTool<any> {\r\n  return tool?.['$brand'] === 'auto-parseable-tool';\r\n}\r\n\r\nfunction getInputToolByName(input_tools: Array<Tool>, name: string): FunctionTool | undefined {\r\n  return input_tools.find((tool) => tool.type === 'function' && tool.name === name) as\r\n    | FunctionTool\r\n    | undefined;\r\n}\r\n\r\nfunction parseToolCall<Params extends ResponseCreateParamsBase>(\r\n  params: Params,\r\n  toolCall: ResponseFunctionToolCall,\r\n): ParsedResponseFunctionToolCall {\r\n  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\r\n\r\n  return {\r\n    ...toolCall,\r\n    ...toolCall,\r\n    parsed_arguments:\r\n      isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments)\r\n      : inputTool?.strict ? JSON.parse(toolCall.arguments)\r\n      : null,\r\n  };\r\n}\r\n\r\nexport function shouldParseToolCall(\r\n  params: ResponseCreateParamsNonStreaming | null | undefined,\r\n  toolCall: ResponseFunctionToolCall,\r\n): boolean {\r\n  if (!params) {\r\n    return false;\r\n  }\r\n\r\n  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\r\n  return isAutoParsableTool(inputTool) || inputTool?.strict || false;\r\n}\r\n\r\nexport function validateInputTools(tools: ChatCompletionTool[] | undefined) {\r\n  for (const tool of tools ?? []) {\r\n    if (tool.type !== 'function') {\r\n      throw new OpenAIError(\r\n        `Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``,\r\n      );\r\n    }\r\n\r\n    if (tool.function.strict !== true) {\r\n      throw new OpenAIError(\r\n        `The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport function addOutputText(rsp: Response): void {\r\n  const texts: string[] = [];\r\n  for (const output of rsp.output) {\r\n    if (output.type !== 'message') {\r\n      continue;\r\n    }\r\n\r\n    for (const content of output.content) {\r\n      if (content.type === 'output_text') {\r\n        texts.push(content.text);\r\n      }\r\n    }\r\n  }\r\n\r\n  rsp.output_text = texts.join('');\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}