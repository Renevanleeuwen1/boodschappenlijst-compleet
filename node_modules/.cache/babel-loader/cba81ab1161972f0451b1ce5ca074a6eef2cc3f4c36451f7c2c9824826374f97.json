{"ast":null,"code":"// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nexport function getDefaultFetch() {\n  if (typeof fetch !== 'undefined') {\n    return fetch;\n  }\n  throw new Error('`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`');\n}\nexport function makeReadableStream(...args) {\n  const ReadableStream = globalThis.ReadableStream;\n  if (typeof ReadableStream === 'undefined') {\n    // Note: All of the platforms / runtimes we officially support already define\n    // `ReadableStream` as a global, so this should only ever be hit on unsupported runtimes.\n    throw new Error('`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`');\n  }\n  return new ReadableStream(...args);\n}\nexport function ReadableStreamFrom(iterable) {\n  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\n  return makeReadableStream({\n    start() {},\n    async pull(controller) {\n      const {\n        done,\n        value\n      } = await iter.next();\n      if (done) {\n        controller.close();\n      } else {\n        controller.enqueue(value);\n      }\n    },\n    async cancel() {\n      await iter.return?.();\n    }\n  });\n}\n/**\r\n * Most browsers don't yet have async iterable support for ReadableStream,\r\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\r\n *\r\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\r\n */\nexport function ReadableStreamToAsyncIterable(stream) {\n  if (stream[Symbol.asyncIterator]) return stream;\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return {\n        done: true,\n        value: undefined\n      };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n}\n/**\r\n * Cancels a ReadableStream we don't need to consume.\r\n * See https://undici.nodejs.org/#/?id=garbage-collection\r\n */\nexport async function CancelReadableStream(stream) {\n  if (stream === null || typeof stream !== 'object') return;\n  if (stream[Symbol.asyncIterator]) {\n    await stream[Symbol.asyncIterator]().return?.();\n    return;\n  }\n  const reader = stream.getReader();\n  const cancelPromise = reader.cancel();\n  reader.releaseLock();\n  await cancelPromise;\n}","map":{"version":3,"names":["getDefaultFetch","fetch","Error","makeReadableStream","args","ReadableStream","globalThis","ReadableStreamFrom","iterable","iter","Symbol","asyncIterator","iterator","start","pull","controller","done","value","next","close","enqueue","cancel","return","ReadableStreamToAsyncIterable","stream","reader","getReader","result","read","releaseLock","e","cancelPromise","undefined","CancelReadableStream"],"sources":["C:\\boodschappenlijst\\boodschappenlijst-compleet\\node_modules\\openai\\src\\internal\\shims.ts"],"sourcesContent":["// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\n/**\r\n * This module provides internal shims and utility functions for environments where certain Node.js or global types may not be available.\r\n *\r\n * These are used to ensure we can provide a consistent behaviour between different JavaScript environments and good error\r\n * messages in cases where an environment isn't fully supported.\r\n */\r\n\r\nimport type { Fetch } from './builtin-types';\r\nimport type { ReadableStream } from './shim-types';\r\n\r\nexport function getDefaultFetch(): Fetch {\r\n  if (typeof fetch !== 'undefined') {\r\n    return fetch as any;\r\n  }\r\n\r\n  throw new Error(\r\n    '`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`',\r\n  );\r\n}\r\n\r\ntype ReadableStreamArgs = ConstructorParameters<typeof ReadableStream>;\r\n\r\nexport function makeReadableStream(...args: ReadableStreamArgs): ReadableStream {\r\n  const ReadableStream = (globalThis as any).ReadableStream;\r\n  if (typeof ReadableStream === 'undefined') {\r\n    // Note: All of the platforms / runtimes we officially support already define\r\n    // `ReadableStream` as a global, so this should only ever be hit on unsupported runtimes.\r\n    throw new Error(\r\n      '`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`',\r\n    );\r\n  }\r\n\r\n  return new ReadableStream(...args);\r\n}\r\n\r\nexport function ReadableStreamFrom<T>(iterable: Iterable<T> | AsyncIterable<T>): ReadableStream<T> {\r\n  let iter: AsyncIterator<T> | Iterator<T> =\r\n    Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\r\n\r\n  return makeReadableStream({\r\n    start() {},\r\n    async pull(controller: any) {\r\n      const { done, value } = await iter.next();\r\n      if (done) {\r\n        controller.close();\r\n      } else {\r\n        controller.enqueue(value);\r\n      }\r\n    },\r\n    async cancel() {\r\n      await iter.return?.();\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Most browsers don't yet have async iterable support for ReadableStream,\r\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\r\n *\r\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\r\n */\r\nexport function ReadableStreamToAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {\r\n  if (stream[Symbol.asyncIterator]) return stream;\r\n\r\n  const reader = stream.getReader();\r\n  return {\r\n    async next() {\r\n      try {\r\n        const result = await reader.read();\r\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\r\n        return result;\r\n      } catch (e) {\r\n        reader.releaseLock(); // release lock when stream becomes errored\r\n        throw e;\r\n      }\r\n    },\r\n    async return() {\r\n      const cancelPromise = reader.cancel();\r\n      reader.releaseLock();\r\n      await cancelPromise;\r\n      return { done: true, value: undefined };\r\n    },\r\n    [Symbol.asyncIterator]() {\r\n      return this;\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Cancels a ReadableStream we don't need to consume.\r\n * See https://undici.nodejs.org/#/?id=garbage-collection\r\n */\r\nexport async function CancelReadableStream(stream: any): Promise<void> {\r\n  if (stream === null || typeof stream !== 'object') return;\r\n\r\n  if (stream[Symbol.asyncIterator]) {\r\n    await stream[Symbol.asyncIterator]().return?.();\r\n    return;\r\n  }\r\n\r\n  const reader = stream.getReader();\r\n  const cancelPromise = reader.cancel();\r\n  reader.releaseLock();\r\n  await cancelPromise;\r\n}\r\n"],"mappings":"AAAA;AAYA,OAAM,SAAUA,eAAeA,CAAA;EAC7B,IAAI,OAAOC,KAAK,KAAK,WAAW,EAAE;IAChC,OAAOA,KAAY;EACrB;EAEA,MAAM,IAAIC,KAAK,CACb,mJAAmJ,CACpJ;AACH;AAIA,OAAM,SAAUC,kBAAkBA,CAAC,GAAGC,IAAwB;EAC5D,MAAMC,cAAc,GAAIC,UAAkB,CAACD,cAAc;EACzD,IAAI,OAAOA,cAAc,KAAK,WAAW,EAAE;IACzC;IACA;IACA,MAAM,IAAIH,KAAK,CACb,yHAAyH,CAC1H;EACH;EAEA,OAAO,IAAIG,cAAc,CAAC,GAAGD,IAAI,CAAC;AACpC;AAEA,OAAM,SAAUG,kBAAkBA,CAAIC,QAAwC;EAC5E,IAAIC,IAAI,GACNC,MAAM,CAACC,aAAa,IAAIH,QAAQ,GAAGA,QAAQ,CAACE,MAAM,CAACC,aAAa,CAAC,EAAE,GAAGH,QAAQ,CAACE,MAAM,CAACE,QAAQ,CAAC,EAAE;EAEnG,OAAOT,kBAAkB,CAAC;IACxBU,KAAKA,CAAA,GAAI,CAAC;IACV,MAAMC,IAAIA,CAACC,UAAe;MACxB,MAAM;QAAEC,IAAI;QAAEC;MAAK,CAAE,GAAG,MAAMR,IAAI,CAACS,IAAI,EAAE;MACzC,IAAIF,IAAI,EAAE;QACRD,UAAU,CAACI,KAAK,EAAE;MACpB,CAAC,MAAM;QACLJ,UAAU,CAACK,OAAO,CAACH,KAAK,CAAC;MAC3B;IACF,CAAC;IACD,MAAMI,MAAMA,CAAA;MACV,MAAMZ,IAAI,CAACa,MAAM,GAAE,CAAE;IACvB;GACD,CAAC;AACJ;AAEA;;;;;;AAMA,OAAM,SAAUC,6BAA6BA,CAAIC,MAAW;EAC1D,IAAIA,MAAM,CAACd,MAAM,CAACC,aAAa,CAAC,EAAE,OAAOa,MAAM;EAE/C,MAAMC,MAAM,GAAGD,MAAM,CAACE,SAAS,EAAE;EACjC,OAAO;IACL,MAAMR,IAAIA,CAAA;MACR,IAAI;QACF,MAAMS,MAAM,GAAG,MAAMF,MAAM,CAACG,IAAI,EAAE;QAClC,IAAID,MAAM,EAAEX,IAAI,EAAES,MAAM,CAACI,WAAW,EAAE,CAAC,CAAC;QACxC,OAAOF,MAAM;MACf,CAAC,CAAC,OAAOG,CAAC,EAAE;QACVL,MAAM,CAACI,WAAW,EAAE,CAAC,CAAC;QACtB,MAAMC,CAAC;MACT;IACF,CAAC;IACD,MAAMR,MAAMA,CAAA;MACV,MAAMS,aAAa,GAAGN,MAAM,CAACJ,MAAM,EAAE;MACrCI,MAAM,CAACI,WAAW,EAAE;MACpB,MAAME,aAAa;MACnB,OAAO;QAAEf,IAAI,EAAE,IAAI;QAAEC,KAAK,EAAEe;MAAS,CAAE;IACzC,CAAC;IACD,CAACtB,MAAM,CAACC,aAAa,IAAC;MACpB,OAAO,IAAI;IACb;GACD;AACH;AAEA;;;;AAIA,OAAO,eAAesB,oBAAoBA,CAACT,MAAW;EACpD,IAAIA,MAAM,KAAK,IAAI,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;EAEnD,IAAIA,MAAM,CAACd,MAAM,CAACC,aAAa,CAAC,EAAE;IAChC,MAAMa,MAAM,CAACd,MAAM,CAACC,aAAa,CAAC,EAAE,CAACW,MAAM,GAAE,CAAE;IAC/C;EACF;EAEA,MAAMG,MAAM,GAAGD,MAAM,CAACE,SAAS,EAAE;EACjC,MAAMK,aAAa,GAAGN,MAAM,CAACJ,MAAM,EAAE;EACrCI,MAAM,CAACI,WAAW,EAAE;EACpB,MAAME,aAAa;AACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}