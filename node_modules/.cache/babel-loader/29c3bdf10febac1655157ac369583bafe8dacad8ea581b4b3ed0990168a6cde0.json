{"ast":null,"code":"import { OpenAIError } from \"../../core/error.mjs\";\n/**\r\n * Percent-encode everything that isn't safe to have in a path without encoding safe chars.\r\n *\r\n * Taken from https://datatracker.ietf.org/doc/html/rfc3986#section-3.3:\r\n * > unreserved  = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\r\n * > sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\r\n * > pchar       = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\r\n */\nexport function encodeURIPath(str) {\n  return str.replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);\n}\nexport const createPathTagFunction = (pathEncoder = encodeURIPath) => function path(statics, ...params) {\n  // If there are no params, no processing is needed.\n  if (statics.length === 1) return statics[0];\n  let postPath = false;\n  const path = statics.reduce((previousValue, currentValue, index) => {\n    if (/[?#]/.test(currentValue)) {\n      postPath = true;\n    }\n    return previousValue + currentValue + (index === params.length ? '' : (postPath ? encodeURIComponent : pathEncoder)(String(params[index])));\n  }, '');\n  const pathOnly = path.split(/[?#]/, 1)[0];\n  const invalidSegments = [];\n  const invalidSegmentPattern = /(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)/gi;\n  let match;\n  // Find all invalid segments\n  while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {\n    invalidSegments.push({\n      start: match.index,\n      length: match[0].length\n    });\n  }\n  if (invalidSegments.length > 0) {\n    let lastEnd = 0;\n    const underline = invalidSegments.reduce((acc, segment) => {\n      const spaces = ' '.repeat(segment.start - lastEnd);\n      const arrows = '^'.repeat(segment.length);\n      lastEnd = segment.start + segment.length;\n      return acc + spaces + arrows;\n    }, '');\n    throw new OpenAIError(`Path parameters result in path with invalid segments:\\n${path}\\n${underline}`);\n  }\n  return path;\n};\n/**\r\n * URI-encodes path params and ensures no unsafe /./ or /../ path segments are introduced.\r\n */\nexport const path = /* @__PURE__ */createPathTagFunction(encodeURIPath);","map":{"version":3,"names":["OpenAIError","encodeURIPath","str","replace","encodeURIComponent","createPathTagFunction","pathEncoder","path","statics","params","length","postPath","reduce","previousValue","currentValue","index","test","String","pathOnly","split","invalidSegments","invalidSegmentPattern","match","exec","push","start","lastEnd","underline","acc","segment","spaces","repeat","arrows"],"sources":["C:\\boodschappenlijst\\boodschappenlijst-compleet\\node_modules\\openai\\src\\internal\\utils\\path.ts"],"sourcesContent":["import { OpenAIError } from '../../core/error';\r\n\r\n/**\r\n * Percent-encode everything that isn't safe to have in a path without encoding safe chars.\r\n *\r\n * Taken from https://datatracker.ietf.org/doc/html/rfc3986#section-3.3:\r\n * > unreserved  = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\r\n * > sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\r\n * > pchar       = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\r\n */\r\nexport function encodeURIPath(str: string) {\r\n  return str.replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);\r\n}\r\n\r\nexport const createPathTagFunction = (pathEncoder = encodeURIPath) =>\r\n  function path(statics: readonly string[], ...params: readonly unknown[]): string {\r\n    // If there are no params, no processing is needed.\r\n    if (statics.length === 1) return statics[0]!;\r\n\r\n    let postPath = false;\r\n    const path = statics.reduce((previousValue, currentValue, index) => {\r\n      if (/[?#]/.test(currentValue)) {\r\n        postPath = true;\r\n      }\r\n      return (\r\n        previousValue +\r\n        currentValue +\r\n        (index === params.length ? '' : (postPath ? encodeURIComponent : pathEncoder)(String(params[index])))\r\n      );\r\n    }, '');\r\n\r\n    const pathOnly = path.split(/[?#]/, 1)[0]!;\r\n    const invalidSegments = [];\r\n    const invalidSegmentPattern = /(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)/gi;\r\n    let match;\r\n\r\n    // Find all invalid segments\r\n    while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {\r\n      invalidSegments.push({\r\n        start: match.index,\r\n        length: match[0].length,\r\n      });\r\n    }\r\n\r\n    if (invalidSegments.length > 0) {\r\n      let lastEnd = 0;\r\n      const underline = invalidSegments.reduce((acc, segment) => {\r\n        const spaces = ' '.repeat(segment.start - lastEnd);\r\n        const arrows = '^'.repeat(segment.length);\r\n        lastEnd = segment.start + segment.length;\r\n        return acc + spaces + arrows;\r\n      }, '');\r\n\r\n      throw new OpenAIError(`Path parameters result in path with invalid segments:\\n${path}\\n${underline}`);\r\n    }\r\n\r\n    return path;\r\n  };\r\n\r\n/**\r\n * URI-encodes path params and ensures no unsafe /./ or /../ path segments are introduced.\r\n */\r\nexport const path = /* @__PURE__ */ createPathTagFunction(encodeURIPath);\r\n"],"mappings":"SAASA,WAAW,QAAE;AAEtB;;;;;;;;AAQA,OAAM,SAAUC,aAAaA,CAACC,GAAW;EACvC,OAAOA,GAAG,CAACC,OAAO,CAAC,kCAAkC,EAAEC,kBAAkB,CAAC;AAC5E;AAEA,OAAO,MAAMC,qBAAqB,GAAGA,CAACC,WAAW,GAAGL,aAAa,KAC/D,SAASM,IAAIA,CAACC,OAA0B,EAAE,GAAGC,MAA0B;EACrE;EACA,IAAID,OAAO,CAACE,MAAM,KAAK,CAAC,EAAE,OAAOF,OAAO,CAAC,CAAC,CAAE;EAE5C,IAAIG,QAAQ,GAAG,KAAK;EACpB,MAAMJ,IAAI,GAAGC,OAAO,CAACI,MAAM,CAAC,CAACC,aAAa,EAAEC,YAAY,EAAEC,KAAK,KAAI;IACjE,IAAI,MAAM,CAACC,IAAI,CAACF,YAAY,CAAC,EAAE;MAC7BH,QAAQ,GAAG,IAAI;IACjB;IACA,OACEE,aAAa,GACbC,YAAY,IACXC,KAAK,KAAKN,MAAM,CAACC,MAAM,GAAG,EAAE,GAAG,CAACC,QAAQ,GAAGP,kBAAkB,GAAGE,WAAW,EAAEW,MAAM,CAACR,MAAM,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC;EAEzG,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMG,QAAQ,GAAGX,IAAI,CAACY,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,CAAE;EAC1C,MAAMC,eAAe,GAAG,EAAE;EAC1B,MAAMC,qBAAqB,GAAG,oCAAoC;EAClE,IAAIC,KAAK;EAET;EACA,OAAO,CAACA,KAAK,GAAGD,qBAAqB,CAACE,IAAI,CAACL,QAAQ,CAAC,MAAM,IAAI,EAAE;IAC9DE,eAAe,CAACI,IAAI,CAAC;MACnBC,KAAK,EAAEH,KAAK,CAACP,KAAK;MAClBL,MAAM,EAAEY,KAAK,CAAC,CAAC,CAAC,CAACZ;KAClB,CAAC;EACJ;EAEA,IAAIU,eAAe,CAACV,MAAM,GAAG,CAAC,EAAE;IAC9B,IAAIgB,OAAO,GAAG,CAAC;IACf,MAAMC,SAAS,GAAGP,eAAe,CAACR,MAAM,CAAC,CAACgB,GAAG,EAAEC,OAAO,KAAI;MACxD,MAAMC,MAAM,GAAG,GAAG,CAACC,MAAM,CAACF,OAAO,CAACJ,KAAK,GAAGC,OAAO,CAAC;MAClD,MAAMM,MAAM,GAAG,GAAG,CAACD,MAAM,CAACF,OAAO,CAACnB,MAAM,CAAC;MACzCgB,OAAO,GAAGG,OAAO,CAACJ,KAAK,GAAGI,OAAO,CAACnB,MAAM;MACxC,OAAOkB,GAAG,GAAGE,MAAM,GAAGE,MAAM;IAC9B,CAAC,EAAE,EAAE,CAAC;IAEN,MAAM,IAAIhC,WAAW,CAAC,0DAA0DO,IAAI,KAAKoB,SAAS,EAAE,CAAC;EACvG;EAEA,OAAOpB,IAAI;AACb,CAAC;AAEH;;;AAGA,OAAO,MAAMA,IAAI,GAAG,eAAgBF,qBAAqB,CAACJ,aAAa,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}