{"ast":null,"code":"var _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionToolCall, _AbstractChatCompletionRunner_getFinalFunctionToolCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;\nimport { __classPrivateFieldGet } from \"../internal/tslib.mjs\";\nimport { OpenAIError } from \"../error.mjs\";\nimport { isRunnableFunctionWithParse } from \"./RunnableFunction.mjs\";\nimport { isAssistantMessage, isToolMessage } from \"./chatCompletionUtils.mjs\";\nimport { EventStream } from \"./EventStream.mjs\";\nimport { isAutoParsableTool, parseChatCompletion } from \"../lib/parser.mjs\";\nconst DEFAULT_MAX_CHAT_COMPLETIONS = 10;\nexport class AbstractChatCompletionRunner extends EventStream {\n  constructor() {\n    super(...arguments);\n    _AbstractChatCompletionRunner_instances.add(this);\n    this._chatCompletions = [];\n    this.messages = [];\n  }\n  _addChatCompletion(chatCompletion) {\n    this._chatCompletions.push(chatCompletion);\n    this._emit('chatCompletion', chatCompletion);\n    const message = chatCompletion.choices[0]?.message;\n    if (message) this._addMessage(message);\n    return chatCompletion;\n  }\n  _addMessage(message, emit = true) {\n    if (!('content' in message)) message.content = null;\n    this.messages.push(message);\n    if (emit) {\n      this._emit('message', message);\n      if (isToolMessage(message) && message.content) {\n        // Note, this assumes that {role: 'tool', content: …} is always the result of a call of tool of type=function.\n        this._emit('functionToolCallResult', message.content);\n      } else if (isAssistantMessage(message) && message.tool_calls) {\n        for (const tool_call of message.tool_calls) {\n          if (tool_call.type === 'function') {\n            this._emit('functionToolCall', tool_call.function);\n          }\n        }\n      }\n    }\n  }\n  /**\r\n   * @returns a promise that resolves with the final ChatCompletion, or rejects\r\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.\r\n   */\n  async finalChatCompletion() {\n    await this.done();\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\n    if (!completion) throw new OpenAIError('stream ended without producing a ChatCompletion');\n    return completion;\n  }\n  /**\r\n   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects\r\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\r\n   */\n  async finalContent() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n  }\n  /**\r\n   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,\r\n   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\r\n   */\n  async finalMessage() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this);\n  }\n  /**\r\n   * @returns a promise that resolves with the content of the final FunctionCall, or rejects\r\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\r\n   */\n  async finalFunctionToolCall() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);\n  }\n  async finalFunctionToolCallResult() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);\n  }\n  async totalUsage() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);\n  }\n  allChatCompletions() {\n    return [...this._chatCompletions];\n  }\n  _emitFinal() {\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\n    if (completion) this._emit('finalChatCompletion', completion);\n    const finalMessage = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this);\n    if (finalMessage) this._emit('finalMessage', finalMessage);\n    const finalContent = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n    if (finalContent) this._emit('finalContent', finalContent);\n    const finalFunctionCall = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);\n    if (finalFunctionCall) this._emit('finalFunctionToolCall', finalFunctionCall);\n    const finalFunctionCallResult = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);\n    if (finalFunctionCallResult != null) this._emit('finalFunctionToolCallResult', finalFunctionCallResult);\n    if (this._chatCompletions.some(c => c.usage)) {\n      this._emit('totalUsage', __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));\n    }\n  }\n  async _createChatCompletion(client, params, options) {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_validateParams).call(this, params);\n    const chatCompletion = await client.chat.completions.create({\n      ...params,\n      stream: false\n    }, {\n      ...options,\n      signal: this.controller.signal\n    });\n    this._connected();\n    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));\n  }\n  async _runChatCompletion(client, params, options) {\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n    return await this._createChatCompletion(client, params, options);\n  }\n  async _runTools(client, params, options) {\n    const role = 'tool';\n    const {\n      tool_choice = 'auto',\n      stream,\n      ...restParams\n    } = params;\n    const singleFunctionToCall = typeof tool_choice !== 'string' && tool_choice?.function?.name;\n    const {\n      maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS\n    } = options || {};\n    // TODO(someday): clean this logic up\n    const inputTools = params.tools.map(tool => {\n      if (isAutoParsableTool(tool)) {\n        if (!tool.$callback) {\n          throw new OpenAIError('Tool given to `.runTools()` that does not have an associated function');\n        }\n        return {\n          type: 'function',\n          function: {\n            function: tool.$callback,\n            name: tool.function.name,\n            description: tool.function.description || '',\n            parameters: tool.function.parameters,\n            parse: tool.$parseRaw,\n            strict: true\n          }\n        };\n      }\n      return tool;\n    });\n    const functionsByName = {};\n    for (const f of inputTools) {\n      if (f.type === 'function') {\n        functionsByName[f.function.name || f.function.function.name] = f.function;\n      }\n    }\n    const tools = 'tools' in params ? inputTools.map(t => t.type === 'function' ? {\n      type: 'function',\n      function: {\n        name: t.function.name || t.function.function.name,\n        parameters: t.function.parameters,\n        description: t.function.description,\n        strict: t.function.strict\n      }\n    } : t) : undefined;\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n    for (let i = 0; i < maxChatCompletions; ++i) {\n      const chatCompletion = await this._createChatCompletion(client, {\n        ...restParams,\n        tool_choice,\n        tools,\n        messages: [...this.messages]\n      }, options);\n      const message = chatCompletion.choices[0]?.message;\n      if (!message) {\n        throw new OpenAIError(`missing message in ChatCompletion response`);\n      }\n      if (!message.tool_calls?.length) {\n        return;\n      }\n      for (const tool_call of message.tool_calls) {\n        if (tool_call.type !== 'function') continue;\n        const tool_call_id = tool_call.id;\n        const {\n          name,\n          arguments: args\n        } = tool_call.function;\n        const fn = functionsByName[name];\n        if (!fn) {\n          const content = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map(name => JSON.stringify(name)).join(', ')}. Please try again`;\n          this._addMessage({\n            role,\n            tool_call_id,\n            content\n          });\n          continue;\n        } else if (singleFunctionToCall && singleFunctionToCall !== name) {\n          const content = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;\n          this._addMessage({\n            role,\n            tool_call_id,\n            content\n          });\n          continue;\n        }\n        let parsed;\n        try {\n          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n        } catch (error) {\n          const content = error instanceof Error ? error.message : String(error);\n          this._addMessage({\n            role,\n            tool_call_id,\n            content\n          });\n          continue;\n        }\n        // @ts-expect-error it can't rule out `never` type.\n        const rawContent = await fn.function(parsed, this);\n        const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n        this._addMessage({\n          role,\n          tool_call_id,\n          content\n        });\n        if (singleFunctionToCall) {\n          return;\n        }\n      }\n    }\n    return;\n  }\n}\n_AbstractChatCompletionRunner_instances = new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent() {\n  return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;\n}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage() {\n  let i = this.messages.length;\n  while (i-- > 0) {\n    const message = this.messages[i];\n    if (isAssistantMessage(message)) {\n      // TODO: support audio here\n      const ret = {\n        ...message,\n        content: message.content ?? null,\n        refusal: message.refusal ?? null\n      };\n      return ret;\n    }\n  }\n  throw new OpenAIError('stream ended without producing a ChatCompletionMessage with role=assistant');\n}, _AbstractChatCompletionRunner_getFinalFunctionToolCall = function _AbstractChatCompletionRunner_getFinalFunctionToolCall() {\n  for (let i = this.messages.length - 1; i >= 0; i--) {\n    const message = this.messages[i];\n    if (isAssistantMessage(message) && message?.tool_calls?.length) {\n      return message.tool_calls.at(-1)?.function;\n    }\n  }\n  return;\n}, _AbstractChatCompletionRunner_getFinalFunctionToolCallResult = function _AbstractChatCompletionRunner_getFinalFunctionToolCallResult() {\n  for (let i = this.messages.length - 1; i >= 0; i--) {\n    const message = this.messages[i];\n    if (isToolMessage(message) && message.content != null && typeof message.content === 'string' && this.messages.some(x => x.role === 'assistant' && x.tool_calls?.some(y => y.type === 'function' && y.id === message.tool_call_id))) {\n      return message.content;\n    }\n  }\n  return;\n}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage() {\n  const total = {\n    completion_tokens: 0,\n    prompt_tokens: 0,\n    total_tokens: 0\n  };\n  for (const {\n    usage\n  } of this._chatCompletions) {\n    if (usage) {\n      total.completion_tokens += usage.completion_tokens;\n      total.prompt_tokens += usage.prompt_tokens;\n      total.total_tokens += usage.total_tokens;\n    }\n  }\n  return total;\n}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams(params) {\n  if (params.n != null && params.n > 1) {\n    throw new OpenAIError('ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.');\n  }\n}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult(rawContent) {\n  return typeof rawContent === 'string' ? rawContent : rawContent === undefined ? 'undefined' : JSON.stringify(rawContent);\n};","map":{"version":3,"names":["OpenAIError","isRunnableFunctionWithParse","isAssistantMessage","isToolMessage","EventStream","isAutoParsableTool","parseChatCompletion","DEFAULT_MAX_CHAT_COMPLETIONS","AbstractChatCompletionRunner","constructor","_chatCompletions","messages","_addChatCompletion","chatCompletion","push","_emit","message","choices","_addMessage","emit","content","tool_calls","tool_call","type","function","finalChatCompletion","done","completion","length","finalContent","__classPrivateFieldGet","_AbstractChatCompletionRunner_instances","_AbstractChatCompletionRunner_getFinalContent","call","finalMessage","_AbstractChatCompletionRunner_getFinalMessage","finalFunctionToolCall","_AbstractChatCompletionRunner_getFinalFunctionToolCall","finalFunctionToolCallResult","_AbstractChatCompletionRunner_getFinalFunctionToolCallResult","totalUsage","_AbstractChatCompletionRunner_calculateTotalUsage","allChatCompletions","_emitFinal","finalFunctionCall","finalFunctionCallResult","some","c","usage","_createChatCompletion","client","params","options","signal","aborted","controller","abort","addEventListener","_AbstractChatCompletionRunner_validateParams","chat","completions","create","stream","_connected","_runChatCompletion","_runTools","role","tool_choice","restParams","singleFunctionToCall","name","maxChatCompletions","inputTools","tools","map","tool","$callback","description","parameters","parse","$parseRaw","strict","functionsByName","f","t","undefined","i","tool_call_id","id","arguments","args","fn","JSON","stringify","Object","keys","join","parsed","error","Error","String","rawContent","_AbstractChatCompletionRunner_stringifyFunctionCallResult","ret","refusal","at","x","y","total","completion_tokens","prompt_tokens","total_tokens","n"],"sources":["C:\\boodschappenlijst\\boodschappenlijst-compleet\\node_modules\\openai\\src\\lib\\AbstractChatCompletionRunner.ts"],"sourcesContent":["import type { CompletionUsage } from '../resources/completions';\r\nimport type {\r\n  ChatCompletion,\r\n  ChatCompletionMessage,\r\n  ChatCompletionMessageParam,\r\n  ChatCompletionCreateParams,\r\n  ChatCompletionTool,\r\n  ChatCompletionMessageToolCall,\r\n} from '../resources/chat/completions';\r\nimport { OpenAIError } from '../error';\r\nimport {\r\n  type RunnableFunction,\r\n  isRunnableFunctionWithParse,\r\n  type BaseFunctionsArgs,\r\n  type RunnableToolFunction,\r\n} from './RunnableFunction';\r\nimport type { ChatCompletionToolRunnerParams } from './ChatCompletionRunner';\r\nimport type { ChatCompletionStreamingToolRunnerParams } from './ChatCompletionStreamingRunner';\r\nimport { isAssistantMessage, isToolMessage } from './chatCompletionUtils';\r\nimport { BaseEvents, EventStream } from './EventStream';\r\nimport type { ParsedChatCompletion } from '../resources/chat/completions';\r\nimport type OpenAI from '../index';\r\nimport { isAutoParsableTool, parseChatCompletion } from '../lib/parser';\r\nimport type { RequestOptions } from '../internal/request-options';\r\n\r\nconst DEFAULT_MAX_CHAT_COMPLETIONS = 10;\r\nexport interface RunnerOptions extends RequestOptions {\r\n  /** How many requests to make before canceling. Default 10. */\r\n  maxChatCompletions?: number;\r\n}\r\n\r\nexport class AbstractChatCompletionRunner<\r\n  EventTypes extends AbstractChatCompletionRunnerEvents,\r\n  ParsedT,\r\n> extends EventStream<EventTypes> {\r\n  protected _chatCompletions: ParsedChatCompletion<ParsedT>[] = [];\r\n  messages: ChatCompletionMessageParam[] = [];\r\n\r\n  protected _addChatCompletion(\r\n    this: AbstractChatCompletionRunner<AbstractChatCompletionRunnerEvents, ParsedT>,\r\n    chatCompletion: ParsedChatCompletion<ParsedT>,\r\n  ): ParsedChatCompletion<ParsedT> {\r\n    this._chatCompletions.push(chatCompletion);\r\n    this._emit('chatCompletion', chatCompletion);\r\n    const message = chatCompletion.choices[0]?.message;\r\n    if (message) this._addMessage(message as ChatCompletionMessageParam);\r\n    return chatCompletion;\r\n  }\r\n\r\n  protected _addMessage(\r\n    this: AbstractChatCompletionRunner<AbstractChatCompletionRunnerEvents, ParsedT>,\r\n    message: ChatCompletionMessageParam,\r\n    emit = true,\r\n  ) {\r\n    if (!('content' in message)) message.content = null;\r\n\r\n    this.messages.push(message);\r\n\r\n    if (emit) {\r\n      this._emit('message', message);\r\n      if (isToolMessage(message) && message.content) {\r\n        // Note, this assumes that {role: 'tool', content: …} is always the result of a call of tool of type=function.\r\n        this._emit('functionToolCallResult', message.content as string);\r\n      } else if (isAssistantMessage(message) && message.tool_calls) {\r\n        for (const tool_call of message.tool_calls) {\r\n          if (tool_call.type === 'function') {\r\n            this._emit('functionToolCall', tool_call.function);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @returns a promise that resolves with the final ChatCompletion, or rejects\r\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.\r\n   */\r\n  async finalChatCompletion(): Promise<ParsedChatCompletion<ParsedT>> {\r\n    await this.done();\r\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\r\n    if (!completion) throw new OpenAIError('stream ended without producing a ChatCompletion');\r\n    return completion;\r\n  }\r\n\r\n  #getFinalContent(): string | null {\r\n    return this.#getFinalMessage().content ?? null;\r\n  }\r\n\r\n  /**\r\n   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects\r\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\r\n   */\r\n  async finalContent(): Promise<string | null> {\r\n    await this.done();\r\n    return this.#getFinalContent();\r\n  }\r\n\r\n  #getFinalMessage(): ChatCompletionMessage {\r\n    let i = this.messages.length;\r\n    while (i-- > 0) {\r\n      const message = this.messages[i];\r\n      if (isAssistantMessage(message)) {\r\n        // TODO: support audio here\r\n        const ret: Omit<ChatCompletionMessage, 'audio'> = {\r\n          ...message,\r\n          content: (message as ChatCompletionMessage).content ?? null,\r\n          refusal: (message as ChatCompletionMessage).refusal ?? null,\r\n        };\r\n        return ret;\r\n      }\r\n    }\r\n    throw new OpenAIError('stream ended without producing a ChatCompletionMessage with role=assistant');\r\n  }\r\n\r\n  /**\r\n   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,\r\n   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\r\n   */\r\n  async finalMessage(): Promise<ChatCompletionMessage> {\r\n    await this.done();\r\n    return this.#getFinalMessage();\r\n  }\r\n\r\n  #getFinalFunctionToolCall(): ChatCompletionMessageToolCall.Function | undefined {\r\n    for (let i = this.messages.length - 1; i >= 0; i--) {\r\n      const message = this.messages[i];\r\n      if (isAssistantMessage(message) && message?.tool_calls?.length) {\r\n        return message.tool_calls.at(-1)?.function;\r\n      }\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * @returns a promise that resolves with the content of the final FunctionCall, or rejects\r\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\r\n   */\r\n  async finalFunctionToolCall(): Promise<ChatCompletionMessageToolCall.Function | undefined> {\r\n    await this.done();\r\n    return this.#getFinalFunctionToolCall();\r\n  }\r\n\r\n  #getFinalFunctionToolCallResult(): string | undefined {\r\n    for (let i = this.messages.length - 1; i >= 0; i--) {\r\n      const message = this.messages[i];\r\n      if (\r\n        isToolMessage(message) &&\r\n        message.content != null &&\r\n        typeof message.content === 'string' &&\r\n        this.messages.some(\r\n          (x) =>\r\n            x.role === 'assistant' &&\r\n            x.tool_calls?.some((y) => y.type === 'function' && y.id === message.tool_call_id),\r\n        )\r\n      ) {\r\n        return message.content;\r\n      }\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  async finalFunctionToolCallResult(): Promise<string | undefined> {\r\n    await this.done();\r\n    return this.#getFinalFunctionToolCallResult();\r\n  }\r\n\r\n  #calculateTotalUsage(): CompletionUsage {\r\n    const total: CompletionUsage = {\r\n      completion_tokens: 0,\r\n      prompt_tokens: 0,\r\n      total_tokens: 0,\r\n    };\r\n    for (const { usage } of this._chatCompletions) {\r\n      if (usage) {\r\n        total.completion_tokens += usage.completion_tokens;\r\n        total.prompt_tokens += usage.prompt_tokens;\r\n        total.total_tokens += usage.total_tokens;\r\n      }\r\n    }\r\n    return total;\r\n  }\r\n\r\n  async totalUsage(): Promise<CompletionUsage> {\r\n    await this.done();\r\n    return this.#calculateTotalUsage();\r\n  }\r\n\r\n  allChatCompletions(): ChatCompletion[] {\r\n    return [...this._chatCompletions];\r\n  }\r\n\r\n  protected override _emitFinal(\r\n    this: AbstractChatCompletionRunner<AbstractChatCompletionRunnerEvents, ParsedT>,\r\n  ) {\r\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\r\n    if (completion) this._emit('finalChatCompletion', completion);\r\n    const finalMessage = this.#getFinalMessage();\r\n    if (finalMessage) this._emit('finalMessage', finalMessage);\r\n    const finalContent = this.#getFinalContent();\r\n    if (finalContent) this._emit('finalContent', finalContent);\r\n\r\n    const finalFunctionCall = this.#getFinalFunctionToolCall();\r\n    if (finalFunctionCall) this._emit('finalFunctionToolCall', finalFunctionCall);\r\n\r\n    const finalFunctionCallResult = this.#getFinalFunctionToolCallResult();\r\n    if (finalFunctionCallResult != null) this._emit('finalFunctionToolCallResult', finalFunctionCallResult);\r\n\r\n    if (this._chatCompletions.some((c) => c.usage)) {\r\n      this._emit('totalUsage', this.#calculateTotalUsage());\r\n    }\r\n  }\r\n\r\n  #validateParams(params: ChatCompletionCreateParams): void {\r\n    if (params.n != null && params.n > 1) {\r\n      throw new OpenAIError(\r\n        'ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.',\r\n      );\r\n    }\r\n  }\r\n\r\n  protected async _createChatCompletion(\r\n    client: OpenAI,\r\n    params: ChatCompletionCreateParams,\r\n    options?: RequestOptions,\r\n  ): Promise<ParsedChatCompletion<ParsedT>> {\r\n    const signal = options?.signal;\r\n    if (signal) {\r\n      if (signal.aborted) this.controller.abort();\r\n      signal.addEventListener('abort', () => this.controller.abort());\r\n    }\r\n    this.#validateParams(params);\r\n\r\n    const chatCompletion = await client.chat.completions.create(\r\n      { ...params, stream: false },\r\n      { ...options, signal: this.controller.signal },\r\n    );\r\n    this._connected();\r\n    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));\r\n  }\r\n\r\n  protected async _runChatCompletion(\r\n    client: OpenAI,\r\n    params: ChatCompletionCreateParams,\r\n    options?: RequestOptions,\r\n  ): Promise<ChatCompletion> {\r\n    for (const message of params.messages) {\r\n      this._addMessage(message, false);\r\n    }\r\n    return await this._createChatCompletion(client, params, options);\r\n  }\r\n\r\n  protected async _runTools<FunctionsArgs extends BaseFunctionsArgs>(\r\n    client: OpenAI,\r\n    params:\r\n      | ChatCompletionToolRunnerParams<FunctionsArgs>\r\n      | ChatCompletionStreamingToolRunnerParams<FunctionsArgs>,\r\n    options?: RunnerOptions,\r\n  ) {\r\n    const role = 'tool' as const;\r\n    const { tool_choice = 'auto', stream, ...restParams } = params;\r\n    const singleFunctionToCall = typeof tool_choice !== 'string' && tool_choice?.function?.name;\r\n    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\r\n\r\n    // TODO(someday): clean this logic up\r\n    const inputTools = params.tools.map((tool): RunnableToolFunction<any> => {\r\n      if (isAutoParsableTool(tool)) {\r\n        if (!tool.$callback) {\r\n          throw new OpenAIError('Tool given to `.runTools()` that does not have an associated function');\r\n        }\r\n\r\n        return {\r\n          type: 'function',\r\n          function: {\r\n            function: tool.$callback,\r\n            name: tool.function.name,\r\n            description: tool.function.description || '',\r\n            parameters: tool.function.parameters as any,\r\n            parse: tool.$parseRaw,\r\n            strict: true,\r\n          },\r\n        };\r\n      }\r\n\r\n      return tool as any as RunnableToolFunction<any>;\r\n    });\r\n\r\n    const functionsByName: Record<string, RunnableFunction<any>> = {};\r\n    for (const f of inputTools) {\r\n      if (f.type === 'function') {\r\n        functionsByName[f.function.name || f.function.function.name] = f.function;\r\n      }\r\n    }\r\n\r\n    const tools: ChatCompletionTool[] =\r\n      'tools' in params ?\r\n        inputTools.map((t) =>\r\n          t.type === 'function' ?\r\n            {\r\n              type: 'function',\r\n              function: {\r\n                name: t.function.name || t.function.function.name,\r\n                parameters: t.function.parameters as Record<string, unknown>,\r\n                description: t.function.description,\r\n                strict: t.function.strict,\r\n              },\r\n            }\r\n          : (t as unknown as ChatCompletionTool),\r\n        )\r\n      : (undefined as any);\r\n\r\n    for (const message of params.messages) {\r\n      this._addMessage(message, false);\r\n    }\r\n\r\n    for (let i = 0; i < maxChatCompletions; ++i) {\r\n      const chatCompletion: ChatCompletion = await this._createChatCompletion(\r\n        client,\r\n        {\r\n          ...restParams,\r\n          tool_choice,\r\n          tools,\r\n          messages: [...this.messages],\r\n        },\r\n        options,\r\n      );\r\n      const message = chatCompletion.choices[0]?.message;\r\n      if (!message) {\r\n        throw new OpenAIError(`missing message in ChatCompletion response`);\r\n      }\r\n      if (!message.tool_calls?.length) {\r\n        return;\r\n      }\r\n\r\n      for (const tool_call of message.tool_calls) {\r\n        if (tool_call.type !== 'function') continue;\r\n        const tool_call_id = tool_call.id;\r\n        const { name, arguments: args } = tool_call.function;\r\n        const fn = functionsByName[name];\r\n\r\n        if (!fn) {\r\n          const content = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(\r\n            functionsByName,\r\n          )\r\n            .map((name) => JSON.stringify(name))\r\n            .join(', ')}. Please try again`;\r\n\r\n          this._addMessage({ role, tool_call_id, content });\r\n          continue;\r\n        } else if (singleFunctionToCall && singleFunctionToCall !== name) {\r\n          const content = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(\r\n            singleFunctionToCall,\r\n          )} requested. Please try again`;\r\n\r\n          this._addMessage({ role, tool_call_id, content });\r\n          continue;\r\n        }\r\n\r\n        let parsed;\r\n        try {\r\n          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\r\n        } catch (error) {\r\n          const content = error instanceof Error ? error.message : String(error);\r\n          this._addMessage({ role, tool_call_id, content });\r\n          continue;\r\n        }\r\n\r\n        // @ts-expect-error it can't rule out `never` type.\r\n        const rawContent = await fn.function(parsed, this);\r\n        const content = this.#stringifyFunctionCallResult(rawContent);\r\n        this._addMessage({ role, tool_call_id, content });\r\n\r\n        if (singleFunctionToCall) {\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  #stringifyFunctionCallResult(rawContent: unknown): string {\r\n    return (\r\n      typeof rawContent === 'string' ? rawContent\r\n      : rawContent === undefined ? 'undefined'\r\n      : JSON.stringify(rawContent)\r\n    );\r\n  }\r\n}\r\n\r\nexport interface AbstractChatCompletionRunnerEvents extends BaseEvents {\r\n  functionToolCall: (functionCall: ChatCompletionMessageToolCall.Function) => void;\r\n  message: (message: ChatCompletionMessageParam) => void;\r\n  chatCompletion: (completion: ChatCompletion) => void;\r\n  finalContent: (contentSnapshot: string) => void;\r\n  finalMessage: (message: ChatCompletionMessageParam) => void;\r\n  finalChatCompletion: (completion: ChatCompletion) => void;\r\n  finalFunctionToolCall: (functionCall: ChatCompletionMessageToolCall.Function) => void;\r\n  functionToolCallResult: (content: string) => void;\r\n  finalFunctionToolCallResult: (content: string) => void;\r\n  totalUsage: (usage: CompletionUsage) => void;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}