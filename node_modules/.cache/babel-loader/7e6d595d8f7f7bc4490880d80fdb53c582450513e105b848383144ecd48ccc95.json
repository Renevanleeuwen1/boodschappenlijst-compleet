{"ast":null,"code":"import WebSocket from './WebSocket';\nimport { CHANNEL_EVENTS, CONNECTION_STATE, DEFAULT_HEADERS, DEFAULT_TIMEOUT, SOCKET_STATES, TRANSPORTS, VSN, WS_CLOSE_NORMAL } from './lib/constants';\nimport Serializer from './lib/serializer';\nimport Timer from './lib/timer';\nimport { httpEndpointURL } from './lib/transformers';\nimport RealtimeChannel from './RealtimeChannel';\nconst noop = () => {};\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`;\nexport default class RealtimeClient {\n  /**\r\n   * Initializes the Socket.\r\n   *\r\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\r\n   * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\r\n   * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\r\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\r\n   * @param options.params The optional params to pass when connecting.\r\n   * @param options.headers The optional headers to pass when connecting.\r\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\r\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\r\n   * @param options.logLevel Sets the log level for Realtime\r\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\r\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\r\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\r\n   * @param options.worker Use Web Worker to set a side flow. Defaults to false.\r\n   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\r\n   */\n  constructor(endPoint, options) {\n    var _a;\n    this.accessTokenValue = null;\n    this.apiKey = null;\n    this.channels = new Array();\n    this.endPoint = '';\n    this.httpEndpoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.heartbeatIntervalMs = 25000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.heartbeatCallback = noop;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.accessToken = null;\n    /**\r\n     * Use either custom fetch, if provided, or default fetch to make HTTP requests\r\n     *\r\n     * @internal\r\n     */\n    this._resolveFetch = customFetch => {\n      let _fetch;\n      if (customFetch) {\n        _fetch = customFetch;\n      } else if (typeof fetch === 'undefined') {\n        _fetch = (...args) => import('@supabase/node-fetch').then(({\n          default: fetch\n        }) => fetch(...args));\n      } else {\n        _fetch = fetch;\n      }\n      return (...args) => _fetch(...args);\n    };\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    this.httpEndpoint = httpEndpointURL(endPoint);\n    if (options === null || options === void 0 ? void 0 : options.transport) {\n      this.transport = options.transport;\n    } else {\n      this.transport = null;\n    }\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {\n      this.logLevel = options.logLevel || options.log_level;\n      this.params = Object.assign(Object.assign({}, this.params), {\n        log_level: this.logLevel\n      });\n    }\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    const accessTokenValue = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey;\n    if (accessTokenValue) {\n      this.accessTokenValue = accessTokenValue;\n      this.apiKey = accessTokenValue;\n    }\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : tries => {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer(async () => {\n      this.disconnect();\n      this.connect();\n    }, this.reconnectAfterMs);\n    this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n    if (options === null || options === void 0 ? void 0 : options.worker) {\n      if (typeof window !== 'undefined' && !window.Worker) {\n        throw new Error('Web Worker is not supported');\n      }\n      this.worker = (options === null || options === void 0 ? void 0 : options.worker) || false;\n      this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\n    }\n    this.accessToken = (options === null || options === void 0 ? void 0 : options.accessToken) || null;\n  }\n  /**\r\n   * Connects the socket, unless already connected.\r\n   */\n  connect() {\n    if (this.conn) {\n      return;\n    }\n    if (!this.transport) {\n      this.transport = WebSocket;\n    }\n    if (this.transport) {\n      // Detect if using the native browser WebSocket\n      const isBrowser = typeof window !== 'undefined' && this.transport === window.WebSocket;\n      if (isBrowser) {\n        this.conn = new this.transport(this.endpointURL());\n      } else {\n        this.conn = new this.transport(this.endpointURL(), undefined, {\n          headers: this.headers\n        });\n      }\n      this.setupConnection();\n      return;\n    }\n    this.conn = new WSWebSocketDummy(this.endpointURL(), undefined, {\n      close: () => {\n        this.conn = null;\n      }\n    });\n  }\n  /**\r\n   * Returns the URL of the websocket.\r\n   * @returns string The URL of the websocket.\r\n   */\n  endpointURL() {\n    return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n      vsn: VSN\n    }));\n  }\n  /**\r\n   * Disconnects the socket.\r\n   *\r\n   * @param code A numeric status code to send on disconnect.\r\n   * @param reason A custom reason for the disconnect.\r\n   */\n  disconnect(code, reason) {\n    if (this.conn) {\n      this.conn.onclose = function () {}; // noop\n      if (code) {\n        this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n      } else {\n        this.conn.close();\n      }\n      this.conn = null;\n      // remove open handles\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.reset();\n      this.channels.forEach(channel => channel.teardown());\n    }\n  }\n  /**\r\n   * Returns all created channels\r\n   */\n  getChannels() {\n    return this.channels;\n  }\n  /**\r\n   * Unsubscribes and removes a single channel\r\n   * @param channel A RealtimeChannel instance\r\n   */\n  async removeChannel(channel) {\n    const status = await channel.unsubscribe();\n    this.channels = this.channels.filter(c => c._joinRef !== channel._joinRef);\n    if (this.channels.length === 0) {\n      this.disconnect();\n    }\n    return status;\n  }\n  /**\r\n   * Unsubscribes and removes all channels\r\n   */\n  async removeAllChannels() {\n    const values_1 = await Promise.all(this.channels.map(channel => channel.unsubscribe()));\n    this.channels = [];\n    this.disconnect();\n    return values_1;\n  }\n  /**\r\n   * Logs the message.\r\n   *\r\n   * For customized logging, `this.logger` can be overridden.\r\n   */\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  /**\r\n   * Returns the current state of the socket.\r\n   */\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting;\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open;\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing;\n      default:\n        return CONNECTION_STATE.Closed;\n    }\n  }\n  /**\r\n   * Returns `true` is the connection is open.\r\n   */\n  isConnected() {\n    return this.connectionState() === CONNECTION_STATE.Open;\n  }\n  channel(topic, params = {\n    config: {}\n  }) {\n    const realtimeTopic = `realtime:${topic}`;\n    const exists = this.getChannels().find(c => c.topic === realtimeTopic);\n    if (!exists) {\n      const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n      this.channels.push(chan);\n      return chan;\n    } else {\n      return exists;\n    }\n  }\n  /**\r\n   * Push out a message if the socket is connected.\r\n   *\r\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\r\n   */\n  push(data) {\n    const {\n      topic,\n      event,\n      payload,\n      ref\n    } = data;\n    const callback = () => {\n      this.encode(data, result => {\n        var _a;\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n      });\n    };\n    this.log('push', `${topic} ${event} (${ref})`, payload);\n    if (this.isConnected()) {\n      callback();\n    } else {\n      this.sendBuffer.push(callback);\n    }\n  }\n  /**\r\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\r\n   *\r\n   * If param is null it will use the `accessToken` callback function or the token set on the client.\r\n   *\r\n   * On callback used, it will set the value of the token internal to the client.\r\n   *\r\n   * @param token A JWT string to override the token set on the client.\r\n   */\n  async setAuth(token = null) {\n    let tokenToSend = token || this.accessToken && (await this.accessToken()) || this.accessTokenValue;\n    if (this.accessTokenValue != tokenToSend) {\n      this.accessTokenValue = tokenToSend;\n      this.channels.forEach(channel => {\n        tokenToSend && channel.updateJoinPayload({\n          access_token: tokenToSend,\n          version: this.headers && this.headers['X-Client-Info']\n        });\n        if (channel.joinedOnce && channel._isJoined()) {\n          channel._push(CHANNEL_EVENTS.access_token, {\n            access_token: tokenToSend\n          });\n        }\n      });\n    }\n  }\n  /**\r\n   * Sends a heartbeat message if the socket is connected.\r\n   */\n  async sendHeartbeat() {\n    var _a;\n    if (!this.isConnected()) {\n      this.heartbeatCallback('disconnected');\n      return;\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n      this.heartbeatCallback('timeout');\n      (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n      return;\n    }\n    this.pendingHeartbeatRef = this._makeRef();\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef\n    });\n    this.heartbeatCallback('sent');\n    await this.setAuth();\n  }\n  onHeartbeat(callback) {\n    this.heartbeatCallback = callback;\n  }\n  /**\r\n   * Flushes send buffer\r\n   */\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach(callback => callback());\n      this.sendBuffer = [];\n    }\n  }\n  /**\r\n   * Return the next message ref, accounting for overflows\r\n   *\r\n   * @internal\r\n   */\n  _makeRef() {\n    let newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n    return this.ref.toString();\n  }\n  /**\r\n   * Unsubscribe from channels with the specified topic.\r\n   *\r\n   * @internal\r\n   */\n  _leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find(c => c.topic === topic && (c._isJoined() || c._isJoining()));\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`);\n      dupChannel.unsubscribe();\n    }\n  }\n  /**\r\n   * Removes a subscription from the socket.\r\n   *\r\n   * @param channel An open subscription.\r\n   *\r\n   * @internal\r\n   */\n  _remove(channel) {\n    this.channels = this.channels.filter(c => c.topic !== channel.topic);\n  }\n  /**\r\n   * Sets up connection handlers.\r\n   *\r\n   * @internal\r\n   */\n  setupConnection() {\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer';\n      this.conn.onopen = () => this._onConnOpen();\n      this.conn.onerror = error => this._onConnError(error);\n      this.conn.onmessage = event => this._onConnMessage(event);\n      this.conn.onclose = event => this._onConnClose(event);\n    }\n  }\n  /** @internal */\n  _onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, msg => {\n      let {\n        topic,\n        event,\n        payload,\n        ref\n      } = msg;\n      if (topic === 'phoenix' && event === 'phx_reply') {\n        this.heartbeatCallback(msg.payload.status == 'ok' ? 'ok' : 'error');\n      }\n      if (ref && ref === this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n      }\n      this.log('receive', `${payload.status || ''} ${topic} ${event} ${ref && '(' + ref + ')' || ''}`, payload);\n      Array.from(this.channels).filter(channel => channel._isMember(topic)).forEach(channel => channel._trigger(event, payload, ref));\n      this.stateChangeCallbacks.message.forEach(callback => callback(msg));\n    });\n  }\n  /** @internal */\n  _onConnOpen() {\n    this.log('transport', `connected to ${this.endpointURL()}`);\n    this.flushSendBuffer();\n    this.reconnectTimer.reset();\n    if (!this.worker) {\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n    } else {\n      if (this.workerUrl) {\n        this.log('worker', `starting worker for from ${this.workerUrl}`);\n      } else {\n        this.log('worker', `starting default worker`);\n      }\n      const objectUrl = this._workerObjectUrl(this.workerUrl);\n      this.workerRef = new Worker(objectUrl);\n      this.workerRef.onerror = error => {\n        this.log('worker', 'worker error', error.message);\n        this.workerRef.terminate();\n      };\n      this.workerRef.onmessage = event => {\n        if (event.data.event === 'keepAlive') {\n          this.sendHeartbeat();\n        }\n      };\n      this.workerRef.postMessage({\n        event: 'start',\n        interval: this.heartbeatIntervalMs\n      });\n    }\n    this.stateChangeCallbacks.open.forEach(callback => callback());\n  }\n  /** @internal */\n  _onConnClose(event) {\n    this.log('transport', 'close', event);\n    this._triggerChanError();\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.reconnectTimer.scheduleTimeout();\n    this.stateChangeCallbacks.close.forEach(callback => callback(event));\n  }\n  /** @internal */\n  _onConnError(error) {\n    this.log('transport', error.message);\n    this._triggerChanError();\n    this.stateChangeCallbacks.error.forEach(callback => callback(error));\n  }\n  /** @internal */\n  _triggerChanError() {\n    this.channels.forEach(channel => channel._trigger(CHANNEL_EVENTS.error));\n  }\n  /** @internal */\n  _appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?';\n    const query = new URLSearchParams(params);\n    return `${url}${prefix}${query}`;\n  }\n  _workerObjectUrl(url) {\n    let result_url;\n    if (url) {\n      result_url = url;\n    } else {\n      const blob = new Blob([WORKER_SCRIPT], {\n        type: 'application/javascript'\n      });\n      result_url = URL.createObjectURL(blob);\n    }\n    return result_url;\n  }\n}\nclass WSWebSocketDummy {\n  constructor(address, _protocols, options) {\n    this.binaryType = 'arraybuffer';\n    this.onclose = () => {};\n    this.onerror = () => {};\n    this.onmessage = () => {};\n    this.onopen = () => {};\n    this.readyState = SOCKET_STATES.connecting;\n    this.send = () => {};\n    this.url = null;\n    this.url = address;\n    this.close = options.close;\n  }\n}","map":{"version":3,"names":["WebSocket","CHANNEL_EVENTS","CONNECTION_STATE","DEFAULT_HEADERS","DEFAULT_TIMEOUT","SOCKET_STATES","TRANSPORTS","VSN","WS_CLOSE_NORMAL","Serializer","Timer","httpEndpointURL","RealtimeChannel","noop","WORKER_SCRIPT","RealtimeClient","constructor","endPoint","options","accessTokenValue","apiKey","channels","Array","httpEndpoint","headers","params","timeout","heartbeatIntervalMs","heartbeatTimer","undefined","pendingHeartbeatRef","heartbeatCallback","ref","logger","conn","sendBuffer","serializer","stateChangeCallbacks","open","close","error","message","accessToken","_resolveFetch","customFetch","_fetch","fetch","args","then","default","websocket","transport","Object","assign","logLevel","log_level","_a","apikey","reconnectAfterMs","tries","encode","payload","callback","JSON","stringify","decode","bind","reconnectTimer","disconnect","connect","worker","window","Worker","Error","workerUrl","isBrowser","endpointURL","setupConnection","WSWebSocketDummy","_appendParams","vsn","code","reason","onclose","clearInterval","reset","forEach","channel","teardown","getChannels","removeChannel","status","unsubscribe","filter","c","_joinRef","length","removeAllChannels","values_1","Promise","all","map","log","kind","msg","data","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","isConnected","topic","config","realtimeTopic","exists","find","chan","push","event","result","send","setAuth","token","tokenToSend","updateJoinPayload","access_token","version","joinedOnce","_isJoined","_push","sendHeartbeat","_makeRef","onHeartbeat","flushSendBuffer","newRef","toString","_leaveOpenTopic","dupChannel","_isJoining","_remove","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","_onConnMessage","_onConnClose","rawMessage","from","_isMember","_trigger","setInterval","objectUrl","_workerObjectUrl","workerRef","terminate","postMessage","interval","_triggerChanError","scheduleTimeout","url","keys","prefix","match","query","URLSearchParams","result_url","blob","Blob","type","URL","createObjectURL","address","_protocols"],"sources":["C:\\boodschappenlijst\\boodschappenlijst-compleet\\node_modules\\@supabase\\realtime-js\\src\\RealtimeClient.ts"],"sourcesContent":["import WebSocket from './WebSocket'\r\n\r\nimport {\r\n  CHANNEL_EVENTS,\r\n  CONNECTION_STATE,\r\n  DEFAULT_HEADERS,\r\n  DEFAULT_TIMEOUT,\r\n  SOCKET_STATES,\r\n  TRANSPORTS,\r\n  VSN,\r\n  WS_CLOSE_NORMAL,\r\n} from './lib/constants'\r\n\r\nimport Serializer from './lib/serializer'\r\nimport Timer from './lib/timer'\r\n\r\nimport { httpEndpointURL } from './lib/transformers'\r\nimport RealtimeChannel from './RealtimeChannel'\r\nimport type { RealtimeChannelOptions } from './RealtimeChannel'\r\n\r\ntype Fetch = typeof fetch\r\n\r\nexport type Channel = {\r\n  name: string\r\n  inserted_at: string\r\n  updated_at: string\r\n  id: number\r\n}\r\nexport type LogLevel = 'info' | 'warn' | 'error'\r\n\r\nexport type RealtimeMessage = {\r\n  topic: string\r\n  event: string\r\n  payload: any\r\n  ref: string\r\n  join_ref?: string\r\n}\r\n\r\nexport type RealtimeRemoveChannelResponse = 'ok' | 'timed out' | 'error'\r\nexport type HeartbeatStatus =\r\n  | 'sent'\r\n  | 'ok'\r\n  | 'error'\r\n  | 'timeout'\r\n  | 'disconnected'\r\n\r\nconst noop = () => {}\r\n\r\nexport interface WebSocketLikeConstructor {\r\n  new (\r\n    address: string | URL,\r\n    _ignored?: any,\r\n    options?: { headers: Object | undefined }\r\n  ): WebSocketLike\r\n}\r\n\r\nexport type WebSocketLike = WebSocket | WSWebSocketDummy\r\n\r\nexport interface WebSocketLikeError {\r\n  error: any\r\n  message: string\r\n  type: string\r\n}\r\n\r\nexport type RealtimeClientOptions = {\r\n  transport?: WebSocketLikeConstructor\r\n  timeout?: number\r\n  heartbeatIntervalMs?: number\r\n  logger?: Function\r\n  encode?: Function\r\n  decode?: Function\r\n  reconnectAfterMs?: Function\r\n  headers?: { [key: string]: string }\r\n  params?: { [key: string]: any }\r\n  //Deprecated: Use it in favour of correct casing `logLevel`\r\n  log_level?: LogLevel\r\n  logLevel?: LogLevel\r\n  fetch?: Fetch\r\n  worker?: boolean\r\n  workerUrl?: string\r\n  accessToken?: () => Promise<string | null>\r\n}\r\n\r\nconst WORKER_SCRIPT = `\r\n  addEventListener(\"message\", (e) => {\r\n    if (e.data.event === \"start\") {\r\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\r\n    }\r\n  });`\r\n\r\nexport default class RealtimeClient {\r\n  accessTokenValue: string | null = null\r\n  apiKey: string | null = null\r\n  channels: RealtimeChannel[] = new Array()\r\n  endPoint: string = ''\r\n  httpEndpoint: string = ''\r\n  headers?: { [key: string]: string } = DEFAULT_HEADERS\r\n  params?: { [key: string]: string } = {}\r\n  timeout: number = DEFAULT_TIMEOUT\r\n  transport: WebSocketLikeConstructor | null\r\n  heartbeatIntervalMs: number = 25000\r\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\r\n  pendingHeartbeatRef: string | null = null\r\n  heartbeatCallback: (status: HeartbeatStatus) => void = noop\r\n  ref: number = 0\r\n  reconnectTimer: Timer\r\n  logger: Function = noop\r\n  logLevel?: LogLevel\r\n  encode: Function\r\n  decode: Function\r\n  reconnectAfterMs: Function\r\n  conn: WebSocketLike | null = null\r\n  sendBuffer: Function[] = []\r\n  serializer: Serializer = new Serializer()\r\n  stateChangeCallbacks: {\r\n    open: Function[]\r\n    close: Function[]\r\n    error: Function[]\r\n    message: Function[]\r\n  } = {\r\n    open: [],\r\n    close: [],\r\n    error: [],\r\n    message: [],\r\n  }\r\n  fetch: Fetch\r\n  accessToken: (() => Promise<string | null>) | null = null\r\n  worker?: boolean\r\n  workerUrl?: string\r\n  workerRef?: Worker\r\n\r\n  /**\r\n   * Initializes the Socket.\r\n   *\r\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\r\n   * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\r\n   * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\r\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\r\n   * @param options.params The optional params to pass when connecting.\r\n   * @param options.headers The optional headers to pass when connecting.\r\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\r\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\r\n   * @param options.logLevel Sets the log level for Realtime\r\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\r\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\r\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\r\n   * @param options.worker Use Web Worker to set a side flow. Defaults to false.\r\n   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\r\n   */\r\n  constructor(endPoint: string, options?: RealtimeClientOptions) {\r\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\r\n    this.httpEndpoint = httpEndpointURL(endPoint)\r\n    if (options?.transport) {\r\n      this.transport = options.transport\r\n    } else {\r\n      this.transport = null\r\n    }\r\n    if (options?.params) this.params = options.params\r\n    if (options?.headers) this.headers = { ...this.headers, ...options.headers }\r\n    if (options?.timeout) this.timeout = options.timeout\r\n    if (options?.logger) this.logger = options.logger\r\n    if (options?.logLevel || options?.log_level) {\r\n      this.logLevel = options.logLevel || options.log_level\r\n      this.params = { ...this.params, log_level: this.logLevel as string }\r\n    }\r\n\r\n    if (options?.heartbeatIntervalMs)\r\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\r\n\r\n    const accessTokenValue = options?.params?.apikey\r\n    if (accessTokenValue) {\r\n      this.accessTokenValue = accessTokenValue\r\n      this.apiKey = accessTokenValue\r\n    }\r\n\r\n    this.reconnectAfterMs = options?.reconnectAfterMs\r\n      ? options.reconnectAfterMs\r\n      : (tries: number) => {\r\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\r\n        }\r\n    this.encode = options?.encode\r\n      ? options.encode\r\n      : (payload: JSON, callback: Function) => {\r\n          return callback(JSON.stringify(payload))\r\n        }\r\n    this.decode = options?.decode\r\n      ? options.decode\r\n      : this.serializer.decode.bind(this.serializer)\r\n    this.reconnectTimer = new Timer(async () => {\r\n      this.disconnect()\r\n      this.connect()\r\n    }, this.reconnectAfterMs)\r\n\r\n    this.fetch = this._resolveFetch(options?.fetch)\r\n    if (options?.worker) {\r\n      if (typeof window !== 'undefined' && !window.Worker) {\r\n        throw new Error('Web Worker is not supported')\r\n      }\r\n      this.worker = options?.worker || false\r\n      this.workerUrl = options?.workerUrl\r\n    }\r\n    this.accessToken = options?.accessToken || null\r\n  }\r\n\r\n  /**\r\n   * Connects the socket, unless already connected.\r\n   */\r\n  connect(): void {\r\n    if (this.conn) {\r\n      return\r\n    }\r\n    if (!this.transport) {\r\n      this.transport = WebSocket\r\n    }\r\n    if (this.transport) {\r\n      // Detect if using the native browser WebSocket\r\n      const isBrowser =\r\n        typeof window !== 'undefined' && this.transport === window.WebSocket\r\n      if (isBrowser) {\r\n        this.conn = new this.transport(this.endpointURL())\r\n      } else {\r\n        this.conn = new this.transport(this.endpointURL(), undefined, {\r\n          headers: this.headers,\r\n        })\r\n      }\r\n      this.setupConnection()\r\n      return\r\n    }\r\n    this.conn = new WSWebSocketDummy(this.endpointURL(), undefined, {\r\n      close: () => {\r\n        this.conn = null\r\n      },\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns the URL of the websocket.\r\n   * @returns string The URL of the websocket.\r\n   */\r\n  endpointURL(): string {\r\n    return this._appendParams(\r\n      this.endPoint,\r\n      Object.assign({}, this.params, { vsn: VSN })\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Disconnects the socket.\r\n   *\r\n   * @param code A numeric status code to send on disconnect.\r\n   * @param reason A custom reason for the disconnect.\r\n   */\r\n  disconnect(code?: number, reason?: string): void {\r\n    if (this.conn) {\r\n      this.conn.onclose = function () {} // noop\r\n      if (code) {\r\n        this.conn.close(code, reason ?? '')\r\n      } else {\r\n        this.conn.close()\r\n      }\r\n      this.conn = null\r\n\r\n      // remove open handles\r\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer)\r\n      this.reconnectTimer.reset()\r\n      this.channels.forEach((channel) => channel.teardown())\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns all created channels\r\n   */\r\n  getChannels(): RealtimeChannel[] {\r\n    return this.channels\r\n  }\r\n\r\n  /**\r\n   * Unsubscribes and removes a single channel\r\n   * @param channel A RealtimeChannel instance\r\n   */\r\n  async removeChannel(\r\n    channel: RealtimeChannel\r\n  ): Promise<RealtimeRemoveChannelResponse> {\r\n    const status = await channel.unsubscribe()\r\n    this.channels = this.channels.filter((c) => c._joinRef !== channel._joinRef)\r\n\r\n    if (this.channels.length === 0) {\r\n      this.disconnect()\r\n    }\r\n\r\n    return status\r\n  }\r\n\r\n  /**\r\n   * Unsubscribes and removes all channels\r\n   */\r\n  async removeAllChannels(): Promise<RealtimeRemoveChannelResponse[]> {\r\n    const values_1 = await Promise.all(\r\n      this.channels.map((channel) => channel.unsubscribe())\r\n    )\r\n    this.channels = []\r\n    this.disconnect()\r\n    return values_1\r\n  }\r\n\r\n  /**\r\n   * Logs the message.\r\n   *\r\n   * For customized logging, `this.logger` can be overridden.\r\n   */\r\n  log(kind: string, msg: string, data?: any) {\r\n    this.logger(kind, msg, data)\r\n  }\r\n\r\n  /**\r\n   * Returns the current state of the socket.\r\n   */\r\n  connectionState(): CONNECTION_STATE {\r\n    switch (this.conn && this.conn.readyState) {\r\n      case SOCKET_STATES.connecting:\r\n        return CONNECTION_STATE.Connecting\r\n      case SOCKET_STATES.open:\r\n        return CONNECTION_STATE.Open\r\n      case SOCKET_STATES.closing:\r\n        return CONNECTION_STATE.Closing\r\n      default:\r\n        return CONNECTION_STATE.Closed\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns `true` is the connection is open.\r\n   */\r\n  isConnected(): boolean {\r\n    return this.connectionState() === CONNECTION_STATE.Open\r\n  }\r\n\r\n  channel(\r\n    topic: string,\r\n    params: RealtimeChannelOptions = { config: {} }\r\n  ): RealtimeChannel {\r\n    const realtimeTopic = `realtime:${topic}`\r\n    const exists = this.getChannels().find(\r\n      (c: RealtimeChannel) => c.topic === realtimeTopic\r\n    )\r\n\r\n    if (!exists) {\r\n      const chan = new RealtimeChannel(`realtime:${topic}`, params, this)\r\n      this.channels.push(chan)\r\n\r\n      return chan\r\n    } else {\r\n      return exists\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Push out a message if the socket is connected.\r\n   *\r\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\r\n   */\r\n  push(data: RealtimeMessage): void {\r\n    const { topic, event, payload, ref } = data\r\n    const callback = () => {\r\n      this.encode(data, (result: any) => {\r\n        this.conn?.send(result)\r\n      })\r\n    }\r\n    this.log('push', `${topic} ${event} (${ref})`, payload)\r\n    if (this.isConnected()) {\r\n      callback()\r\n    } else {\r\n      this.sendBuffer.push(callback)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\r\n   *\r\n   * If param is null it will use the `accessToken` callback function or the token set on the client.\r\n   *\r\n   * On callback used, it will set the value of the token internal to the client.\r\n   *\r\n   * @param token A JWT string to override the token set on the client.\r\n   */\r\n  async setAuth(token: string | null = null): Promise<void> {\r\n    let tokenToSend =\r\n      token ||\r\n      (this.accessToken && (await this.accessToken())) ||\r\n      this.accessTokenValue\r\n\r\n    if (this.accessTokenValue != tokenToSend) {\r\n      this.accessTokenValue = tokenToSend\r\n      this.channels.forEach((channel) => {\r\n        tokenToSend &&\r\n          channel.updateJoinPayload({\r\n            access_token: tokenToSend,\r\n            version: this.headers && this.headers['X-Client-Info'],\r\n          })\r\n\r\n        if (channel.joinedOnce && channel._isJoined()) {\r\n          channel._push(CHANNEL_EVENTS.access_token, {\r\n            access_token: tokenToSend,\r\n          })\r\n        }\r\n      })\r\n    }\r\n  }\r\n  /**\r\n   * Sends a heartbeat message if the socket is connected.\r\n   */\r\n  async sendHeartbeat() {\r\n    if (!this.isConnected()) {\r\n      this.heartbeatCallback('disconnected')\r\n      return\r\n    }\r\n    if (this.pendingHeartbeatRef) {\r\n      this.pendingHeartbeatRef = null\r\n      this.log(\r\n        'transport',\r\n        'heartbeat timeout. Attempting to re-establish connection'\r\n      )\r\n      this.heartbeatCallback('timeout')\r\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\r\n      return\r\n    }\r\n    this.pendingHeartbeatRef = this._makeRef()\r\n    this.push({\r\n      topic: 'phoenix',\r\n      event: 'heartbeat',\r\n      payload: {},\r\n      ref: this.pendingHeartbeatRef,\r\n    })\r\n    this.heartbeatCallback('sent')\r\n    await this.setAuth()\r\n  }\r\n\r\n  onHeartbeat(callback: (status: HeartbeatStatus) => void): void {\r\n    this.heartbeatCallback = callback\r\n  }\r\n  /**\r\n   * Flushes send buffer\r\n   */\r\n  flushSendBuffer() {\r\n    if (this.isConnected() && this.sendBuffer.length > 0) {\r\n      this.sendBuffer.forEach((callback) => callback())\r\n      this.sendBuffer = []\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Use either custom fetch, if provided, or default fetch to make HTTP requests\r\n   *\r\n   * @internal\r\n   */\r\n  _resolveFetch = (customFetch?: Fetch): Fetch => {\r\n    let _fetch: Fetch\r\n    if (customFetch) {\r\n      _fetch = customFetch\r\n    } else if (typeof fetch === 'undefined') {\r\n      _fetch = (...args) =>\r\n        import('@supabase/node-fetch' as any).then(({ default: fetch }) =>\r\n          fetch(...args)\r\n        )\r\n    } else {\r\n      _fetch = fetch\r\n    }\r\n    return (...args) => _fetch(...args)\r\n  }\r\n\r\n  /**\r\n   * Return the next message ref, accounting for overflows\r\n   *\r\n   * @internal\r\n   */\r\n  _makeRef(): string {\r\n    let newRef = this.ref + 1\r\n    if (newRef === this.ref) {\r\n      this.ref = 0\r\n    } else {\r\n      this.ref = newRef\r\n    }\r\n\r\n    return this.ref.toString()\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from channels with the specified topic.\r\n   *\r\n   * @internal\r\n   */\r\n  _leaveOpenTopic(topic: string): void {\r\n    let dupChannel = this.channels.find(\r\n      (c) => c.topic === topic && (c._isJoined() || c._isJoining())\r\n    )\r\n    if (dupChannel) {\r\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\r\n      dupChannel.unsubscribe()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a subscription from the socket.\r\n   *\r\n   * @param channel An open subscription.\r\n   *\r\n   * @internal\r\n   */\r\n  _remove(channel: RealtimeChannel) {\r\n    this.channels = this.channels.filter((c) => c.topic !== channel.topic)\r\n  }\r\n\r\n  /**\r\n   * Sets up connection handlers.\r\n   *\r\n   * @internal\r\n   */\r\n  private setupConnection(): void {\r\n    if (this.conn) {\r\n      this.conn.binaryType = 'arraybuffer'\r\n      this.conn.onopen = () => this._onConnOpen()\r\n      this.conn.onerror = (error: WebSocketLikeError) =>\r\n        this._onConnError(error as WebSocketLikeError)\r\n      this.conn.onmessage = (event: any) => this._onConnMessage(event)\r\n      this.conn.onclose = (event: any) => this._onConnClose(event)\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  private _onConnMessage(rawMessage: { data: any }) {\r\n    this.decode(rawMessage.data, (msg: RealtimeMessage) => {\r\n      let { topic, event, payload, ref } = msg\r\n\r\n      if (topic === 'phoenix' && event === 'phx_reply') {\r\n        this.heartbeatCallback(msg.payload.status == 'ok' ? 'ok' : 'error')\r\n      }\r\n\r\n      if (ref && ref === this.pendingHeartbeatRef) {\r\n        this.pendingHeartbeatRef = null\r\n      }\r\n\r\n      this.log(\r\n        'receive',\r\n        `${payload.status || ''} ${topic} ${event} ${\r\n          (ref && '(' + ref + ')') || ''\r\n        }`,\r\n        payload\r\n      )\r\n\r\n      Array.from(this.channels)\r\n        .filter((channel: RealtimeChannel) => channel._isMember(topic))\r\n        .forEach((channel: RealtimeChannel) =>\r\n          channel._trigger(event, payload, ref)\r\n        )\r\n\r\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\r\n    })\r\n  }\r\n\r\n  /** @internal */\r\n  private _onConnOpen() {\r\n    this.log('transport', `connected to ${this.endpointURL()}`)\r\n    this.flushSendBuffer()\r\n    this.reconnectTimer.reset()\r\n    if (!this.worker) {\r\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer)\r\n      this.heartbeatTimer = setInterval(\r\n        () => this.sendHeartbeat(),\r\n        this.heartbeatIntervalMs\r\n      )\r\n    } else {\r\n      if (this.workerUrl) {\r\n        this.log('worker', `starting worker for from ${this.workerUrl}`)\r\n      } else {\r\n        this.log('worker', `starting default worker`)\r\n      }\r\n      const objectUrl = this._workerObjectUrl(this.workerUrl!)\r\n      this.workerRef = new Worker(objectUrl)\r\n      this.workerRef.onerror = (error) => {\r\n        this.log('worker', 'worker error', (error as ErrorEvent).message)\r\n        this.workerRef!.terminate()\r\n      }\r\n      this.workerRef.onmessage = (event) => {\r\n        if (event.data.event === 'keepAlive') {\r\n          this.sendHeartbeat()\r\n        }\r\n      }\r\n      this.workerRef.postMessage({\r\n        event: 'start',\r\n        interval: this.heartbeatIntervalMs,\r\n      })\r\n    }\r\n    this.stateChangeCallbacks.open.forEach((callback) => callback())\r\n  }\r\n\r\n  /** @internal */\r\n  private _onConnClose(event: any) {\r\n    this.log('transport', 'close', event)\r\n    this._triggerChanError()\r\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\r\n    this.reconnectTimer.scheduleTimeout()\r\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\r\n  }\r\n\r\n  /** @internal */\r\n  private _onConnError(error: WebSocketLikeError) {\r\n    this.log('transport', error.message)\r\n    this._triggerChanError()\r\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\r\n  }\r\n\r\n  /** @internal */\r\n  private _triggerChanError() {\r\n    this.channels.forEach((channel: RealtimeChannel) =>\r\n      channel._trigger(CHANNEL_EVENTS.error)\r\n    )\r\n  }\r\n\r\n  /** @internal */\r\n  private _appendParams(\r\n    url: string,\r\n    params: { [key: string]: string }\r\n  ): string {\r\n    if (Object.keys(params).length === 0) {\r\n      return url\r\n    }\r\n    const prefix = url.match(/\\?/) ? '&' : '?'\r\n    const query = new URLSearchParams(params)\r\n    return `${url}${prefix}${query}`\r\n  }\r\n\r\n  private _workerObjectUrl(url: string | undefined): string {\r\n    let result_url: string\r\n    if (url) {\r\n      result_url = url\r\n    } else {\r\n      const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' })\r\n      result_url = URL.createObjectURL(blob)\r\n    }\r\n    return result_url\r\n  }\r\n}\r\n\r\nclass WSWebSocketDummy {\r\n  binaryType: string = 'arraybuffer'\r\n  close: Function\r\n  onclose: Function = () => {}\r\n  onerror: Function = () => {}\r\n  onmessage: Function = () => {}\r\n  onopen: Function = () => {}\r\n  readyState: number = SOCKET_STATES.connecting\r\n  send: Function = () => {}\r\n  url: string | URL | null = null\r\n\r\n  constructor(\r\n    address: string,\r\n    _protocols: undefined,\r\n    options: { close: Function }\r\n  ) {\r\n    this.url = address\r\n    this.close = options.close\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}